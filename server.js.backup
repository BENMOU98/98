// Updated server.js with database integration
const express = require('express');
const session = require('express-session');
const bodyParser = require('body-parser');
const path = require('path');
const fs = require('fs');
const dotenv = require('dotenv');
const axios = require('axios');
const moment = require('moment');
const { v4: uuidv4 } = require('uuid');
const { generatePinterestContent, generateBlogPost, generateFacebookContent } = require('./app');
const { recipeDb, facebookDb, pinterestDb, blogDb, keywordsDb } = require('./db');
const expressLayouts = require('express-ejs-layouts');
const WordPressClient = require('./wordpress');
const wordpressDb = require('./wordpress-db');
const apiKeyManager = require('./api-key-manager');
const recipeTemplateSettings = require('./recipe-template-settings');
const userDb = require('./models/user');
const organizationDb = require('./models/organization');
const { isAuthenticated, isAdmin, isEmployee, isResourceOwner, attachOrganizationToRequest, attachUserToLocals } = require('./middleware/auth');
const authRoutes = require('./auth-routes');
const registrationRoutes = require('./registration-routes');
const activityMiddleware = require('./middleware/activity-middleware');
const { runQuery, getOne, getAll } = require('./db');
const websiteDb = require('./models/website');
const fixAttachUserToLocals = require('./fix-template-variables');




// Load environment variables
dotenv.config();

// Load environment variables
dotenv.config();

// Add this code for API key management
const { getApiKey, saveApiKey, isApiKeyMissing } = require('./api-key-manager');

// Replace your checkApiKeyMiddleware function with this
async function checkApiKeyMiddleware(req, res, next) {
  // Skip check for authentication-related routes and public routes
  const exemptRoutes = [
    '/login', 
    '/register',
    '/logout',
    '/settings', 
    '/api/test-connection',
    '/favicon.ico',
    '/public',
    '/api/keys'
  ];
  
  // Check if the current route is exempt
  for (const route of exemptRoutes) {
    if (req.path.startsWith(route)) {
      return next();
    }
  }
  
  // Check if OpenAI API key is missing
  const openaiKeyMissing = await isApiKeyMissing('openai');
  
  if (openaiKeyMissing) {
    // If it's an API request, return JSON error
    if (req.path.startsWith('/api/')) {
      return res.status(400).json({
        success: false,
        message: 'OpenAI API key is required. Please add your API key in the settings page.'
      });
    }
    
    // For regular page requests, redirect to settings with a warning
    req.session.errorMessage = 'OpenAI API key is required to use this application. Please add your API key below.';
    return res.redirect('/settings');
  }
  
  next();
}


// Initialize Express app
const app = express();
const PORT = process.env.PORT || 3000;


app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use(express.static(path.join(__dirname, 'public')));

// Set up sessions with proper configuration
app.use(session({
  secret: 'recipe-content-generator-secret',
  resave: false,
  saveUninitialized: true,
  cookie: {
    secure: process.env.NODE_ENV === 'production', // Set to true in production
    maxAge: 1000 * 60 * 60 * 24 // 24 hours
  }
}));

// Add these debugging lines after session middleware to check session state
app.use((req, res, next) => {
  // Debug session info without exposing sensitive data
  console.log('Session debug:', {
    hasSession: !!req.session,
    hasUser: !!(req.session && req.session.user),
    sessionID: req.sessionID,
    url: req.originalUrl
  });
  next();
});

// Setup view engine and layouts
app.use(expressLayouts);
app.set('layout', 'layout');
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));

// Add this middleware to set global website context
app.use((req, res, next) => {
  // Set global currentWebsiteId if it exists in session
  if (req.session && req.session.currentWebsiteId) {
    global.currentWebsiteId = req.session.currentWebsiteId;
  }
  next();
});

app.use(require('./middleware/website-auth').attachWebsiteToRequest);
app.use(require('./middleware/website-auth').getUserWebsites);

// First, import the middleware module
const websiteMiddleware = require('./middleware/website-auth');

// Check if the expected middleware functions exist
console.log('Available middleware functions:', Object.keys(websiteMiddleware));

// Then use only what's available
if (websiteMiddleware.attachWebsiteToRequest) {
  app.use(websiteMiddleware.attachWebsiteToRequest);
}

if (websiteMiddleware.getUserWebsites) {
  app.use(websiteMiddleware.getUserWebsites);
}

if (websiteMiddleware.checkWebsiteSetup) {
  app.use(websiteMiddleware.checkWebsiteSetup);
}


// THEN add website routes
const websiteRoutes = require('./website-routes');
app.use(websiteRoutes);

// Fix the middleware order - CRITICAL CHANGE
app.use(require('./middleware/auth').attachOrganizationToRequest);
app.use(fixAttachUserToLocals);
app.use(require('./middleware/auth').adminOnlyPages);





// Check API key middleware should come after authentication
app.use(checkApiKeyMiddleware);


// GET route for user add page
app.get('/users/add', isAuthenticated, isAdmin, (req, res) => {
  res.render('user-add', {
    pageTitle: 'Add User',
    activePage: 'users',
    title: 'RecipeGen AI - Add User'
  });
});

// POST route for adding user (edit this in server.js)
app.post('/users/add', isAuthenticated, isAdmin, async (req, res) => {
  try {
    console.log('User add form submitted:', req.body); // Add this line
    
    const { name, email, username, password, role } = req.body;
    
    // Validate required fields
    if (!name || !email || !username || !password || !role) {
      req.session.errorMessage = 'All fields are required.';
      return res.redirect('/users/add');
    }
    
    // Create user - Make sure this actually calls the database function
    const userId = await userDb.createUser({
      name,
      email,
      username, 
      password,
      role,
      organizationId: req.session.user.organizationId
    });
    
    if (userId) {
      req.session.successMessage = 'User created successfully';
      return res.redirect('/users');
    } else {
      req.session.errorMessage = 'Failed to create user';
      return res.redirect('/users/add');
    }
  } catch (error) {
    console.error('Error creating user:', error);
    req.session.errorMessage = 'Failed to create user: ' + error.message;
    return res.redirect('/users/add');
  }
});

// IMPORTANT: Mount routes properly
app.use('/', registrationRoutes);  // Add this line FIRST
app.use('/', authRoutes);

// Add this code to server.js right after your imports
// It will create a safer version of the getFilteredContent function that catches errors for missing tables

// Add this helper function at the beginning of server.js (after imports)
async function getFilteredContent(organizationId, employeeId = null, contentType = 'all') {
  let content = [];
  
  // Filter by owner if specified
  const ownerFilter = employeeId ? `AND owner_id = '${employeeId}'` : '';
  
  try {
    // Get recipes if requested
    if (contentType === 'all' || contentType === 'recipe') {
      const recipes = await getAll(`
        SELECT r.id, r.recipe_idea as title, 'recipe' as type, r.created_at,
               u.name as owner_name, u.role as owner_role
        FROM recipes r
        LEFT JOIN users u ON r.owner_id = u.id
        WHERE r.organization_id = ? ${ownerFilter}
        ORDER BY r.created_at DESC
        LIMIT 20
      `, [organizationId]);
      
      content.push(...recipes);
    }
    
    // Get keywords if requested
    if (contentType === 'all' || contentType === 'keyword') {
      const keywords = await getAll(`
        SELECT k.id, k.keyword as title, 'keyword' as type, k.added_at as created_at,
               u.name as owner_name, u.role as owner_role
        FROM keywords k
        LEFT JOIN users u ON k.owner_id = u.id
        WHERE k.organization_id = ? ${ownerFilter}
        ORDER BY k.added_at DESC
        LIMIT 20
      `, [organizationId]);
      
      content.push(...keywords);
    }
    
    // Get WordPress posts if requested - use try/catch to handle missing table
    if (contentType === 'all' || contentType === 'blog') {
      try {
        // First check if the wordpress_publications table exists (this is our actual table)
        const tableCheck = await getOne(`
          SELECT name FROM sqlite_master 
          WHERE type='table' AND name='wordpress_publications'
        `);
        
        if (tableCheck) {
          // Use wordpress_publications which is the correct table
          const blogPosts = await getAll(`
            SELECT wp.id, 'WordPress Post' as title, 'blog' as type, wp.created_at,
                  r.owner_id, u.name as owner_name, u.role as owner_role
            FROM wordpress_publications wp
            JOIN recipes r ON wp.recipe_id = r.id
            LEFT JOIN users u ON r.owner_id = u.id
            WHERE r.organization_id = ? ${ownerFilter}
            ORDER BY wp.created_at DESC
            LIMIT 20
          `, [organizationId]);
          
          content.push(...blogPosts);
        }
      } catch (error) {
        console.warn('Error fetching WordPress posts (table may not exist yet):', error.message);
        // Continue without WordPress posts
      }
    }
    
    // Sort all content by creation date
    content.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
    
    // Format dates
    content.forEach(item => {
      if (item.created_at) {
        const date = new Date(item.created_at);
        item.created_at = date.toLocaleDateString('en-US', { 
          year: 'numeric', 
          month: 'short', 
          day: 'numeric' 
        });
      }
    });
    
    return { success: true, content: content.slice(0, 20) };
  } catch (error) {
    console.error('Error getting filtered content:', error);
    return { success: false, message: 'Failed to load filtered content', error: error.message };
  }
}

// API endpoint to check API key status without revealing the key
app.get('/api/keys/status', async (req, res) => {
  try {
    const openaiKeyExists = !(await isApiKeyMissing('openai'));
    
    res.json({
      success: true,
      keys: {
        openai: openaiKeyExists
      }
    });
  } catch (error) {
    console.error('Error checking API key status:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to check API key status'
    });
  }
});


// Default prompts configuration
let promptConfig = {
  model: process.env.DEFAULT_MODEL || 'gpt-4-turbo-preview',
  temperature: parseFloat(process.env.DEFAULT_TEMPERATURE || '0.7'),
  apiKey: process.env.OPENAI_API_KEY,
  language: process.env.DEFAULT_LANGUAGE || 'English',
  pinCount: parseInt(process.env.DEFAULT_PIN_COUNT || '10'),
  prompts: {
    pinTitleSystem: process.env.PIN_TITLE_SYSTEM_PROMPT || `You are a copywriting expert specialized in Pinterest Pin titles. Your task is to generate 10 different Pinterest titles for each keyword or idea, using proven high-conversion techniques.

Title formats:

Title 1: Clear & Concise Titles
Delivering the recipe's value in a straightforward way helps users instantly understand what to expect.
Example: Easy Chicken Alfredo Pasta Recipe

Title 2: Curiosity Titles
Creating a sense of intrigue encourages readers to click and discover the secret, twist, or surprise behind the recipe.
Example: The Secret to Fluffy Pancakes Everyone Gets Wrong

Title 3: Number-Based Titles
Using numbers adds structure and specificity, making the post feel scannable and promising actionable takeaways.
Example: 5 Quick Air Fryer Chicken Recipes for Busy Weeknights

Title 4: "How-To" / Instructional Titles
These titles promise a clear, step-by-step guide, appealing to readers seeking specific instructions.
Example: How to Make Perfect Japanese SoufflÃ© Pancakes at Home

Title 5: Question-Based Titles
Posing a question piques curiosity and encourages clicks, especially when addressing common problems or desires.
Example: Craving Fluffy Pancakes? Try This Easy SoufflÃ© Recipe!

Title 6: Mistake-Avoidance Titles
Highlighting common errors and how to avoid them can attract readers looking to improve their skills.
Example: Avoid These 5 Common Mistakes When Making SoufflÃ© Pancakes

Title 7: Ultimate Guide / Comprehensive Titles
Offering an all-in-one resource appeals to readers seeking in-depth information.
Example: The Ultimate Guide to Making Fluffy Japanese SoufflÃ© Pancakes

Title 8: Comparison Titles
Comparing methods or ingredients can help readers make informed choices.
Example: SoufflÃ© Pancakes vs. Traditional Pancakes: What's the Difference?

Title 9: Seasonal or Occasion-Based Titles
Tying recipes to seasons or events can increase relevance and urgency.
Example: Spring Brunch Delight: Fluffy SoufflÃ© Pancakes Recipe

Title 10: Trend-Focused Titles
Leveraging current trends or viral topics can boost visibility.
Example: TikTok's Viral SoufflÃ© Pancakes: Try the Recipe Everyone's Talking About

Context:

You're helping a food & lifestyle blogger attract attention on Pinterest. Users are quickly scrolling, so your titles must stop the scroll, spark interest, and encourage saves/clicks. Titles must also help the Pin rank in Pinterest search.

Instructions:

1. Use clear and concise language â€” strong verbs, no fluff
2. Highlight the benefit â€” make the result or value obvious
3. Create curiosity â€” tease secrets, ask questions, or spark intrigue
4. Use numbers/lists â€” if the topic allows, add structure with numbers
5. Use natural language with SEO keywords front-loaded
6. Keep each title under 100 characters
7. Write in a friendly, conversational tone like a real food or home blogger

Bad vs. Good Examples:

1. Clear & Concise Titles
âŒ "Chicken dinner idea" â†’ âœ… "Easy Baked Lemon Chicken Thighs"
âŒ "Soup I love" â†’ âœ… "Creamy Tomato Basil Soup Recipe"
âŒ "Slow cooker something" â†’ âœ… "Slow Cooker Pulled Pork Sandwiches"

2. Curiosity Titles
âŒ "Cool pancake recipe" â†’ âœ… "The Secret to Fluffy Pancakes Everyone Gets Wrong"
âŒ "Another slow cooker recipe" â†’ âœ… "Why I Always Add This to My Crockpot Chicken"
âŒ "Easy dessert idea" â†’ âœ… "The 2-Ingredient Chocolate Mousse That Feels Fancy"

3. Number-Based Titles
âŒ "Quick breakfast meals" â†’ âœ… "5 Cozy Fall Breakfasts You'll Crave"
âŒ "Ideas for pasta night" â†’ âœ… "7 Easy Pasta Recipes for Busy Weeknights"
âŒ "Dinner tips" â†’ âœ… "3 Tricks for Juicier Chicken Every Time"

4. How-To / Instructional Titles
âŒ "Best banana bread" â†’ âœ… "How to Make Moist Banana Bread That Never Fails"
âŒ "Easy pancakes" â†’ âœ… "How to Make Fluffy Pancakes from Scratch"
âŒ "Quick salad idea" â†’ âœ… "How to Build the Perfect Summer Salad in 10 Minutes"

5. Question Titles
âŒ "Try these meatballs" â†’ âœ… "Can You Make Meatballs Without Breadcrumbs?"
âŒ "Tips for baking bread" â†’ âœ… "Is Homemade Bread Really Worth It?"
âŒ "Taco recipe here" â†’ âœ… "What's the Secret to the Best Taco Tuesday?"

6. Mistake-Avoidance Titles
âŒ "Bread baking tips" â†’ âœ… "Avoid These 5 Mistakes When Baking Bread"
âŒ "How to roast chicken" â†’ âœ… "Stop Doing This When Roasting a Whole Chicken"
âŒ "Make better cookies" â†’ âœ… "Why Your Cookies Turn Out Flat â€” And How to Fix Them"

7. Ultimate Guide Titles
âŒ "SoufflÃ© recipe" â†’ âœ… "The Ultimate Guide to Making SoufflÃ© Pancakes at Home"
âŒ "Baking bread" â†’ âœ… "Beginner's Guide to Homemade Sourdough"
âŒ "Meal prep" â†’ âœ… "The Ultimate 7-Day Meal Prep Plan for Busy Families"

8. Comparison Titles
âŒ "Soup recipe" â†’ âœ… "Instant Pot vs. Crockpot: Which Makes Better Chicken Soup?"
âŒ "Smoothie vs juice" â†’ âœ… "Green Smoothies vs. Juices: Which Is Healthier?"
âŒ "Microwave vs oven" â†’ âœ… "Microwave Mug Cakes vs. Oven-Baked: What's the Real Difference?"

9. Seasonal / Occasion-Based Titles
âŒ "Apple pie recipe" â†’ âœ… "Cozy Fall Apple Pie with Maple Crust"
âŒ "Some Thanksgiving food" â†’ âœ… "Easy Thanksgiving Sides to Impress Your Guests"
âŒ "Soup idea" â†’ âœ… "Winter Comfort: Creamy Chicken Noodle Soup"

10. Trend-Focused Titles
âŒ "Cool new recipe" â†’ âœ… "TikTok's Viral Grinder Salad Sandwich â€” Worth the Hype?"
âŒ "What's popular now" â†’ âœ… "These Butter Boards Are Taking Over Pinterest"
âŒ "Soup trend" â†’ âœ… "Cottage Cheese Ice Cream: What Happens When You Try It?"`,
    
    pinTitleUser: process.env.PIN_TITLE_USER_PROMPT || `Recipe Idea: {{recipeIdea}}
Language: {{language}}
Please generate {{pinCount}} different Pinterest Pin titles that follow the formatting and guidance provided in the system prompt. Use the keyword, interests, and recipe idea to create attention-grabbing, high-conversion titles. 
Return only the final text without any numbering, dashes, labels, or quotation marks. Do not include "Title 1:", "1.", "-", or any symbols. Just plain clean text.`,
    
    pinDescSystem: process.env.PIN_DESC_SYSTEM_PROMPT || `You are a Pinterest marketing and copywriting expert. Your task is to generate highly effective Pinterest Pin descriptions for blog post Pins that maximize engagement and click-throughs. Each description must serve both the Pinterest algorithm and real human readers.
Follow these strict principles:
1. Start with relevant, **front-loaded keywords** based on the Pin topic â€” what users are likely to search
2. Use **natural, conversational language** (like friendly advice from a blogger)
3. Be **clear and benefit-driven** â€” what problem does this Pin solve or what value does it offer?
4. Add a **a natural, benefit-focused nudge that encourages action without sounding pushy** (e.g., "Don't be surprised if this becomes your new favorite" or "A cozy dinner idea worth trying this week")
5. End with **2â€“3 relevant broad hashtags** (max) that match Pinterest SEO best practices
6. Keep each description between **100â€“200 characters**
Tone: Warm, helpful, modern. You are writing for American women home cooks or lifestyle lovers.
Bad vs Good examples (with indirect CTAs):
âŒ "Here's a pin about meal prep ideas for the week"
âœ… "Meal prep just got easier with these 5 make-ahead dinners for busy nights. One to keep in your weekly rotation. #mealprep #weeknightmeals"
âŒ "How to make fall wreaths"
âœ… "Learn how to make a beautiful fall wreath in under 30 minutes â€” a cozy DIY project you'll want to recreate. #fallwreath #diyhomedecor"
Always output:
- 1 Pinterest-optimized description in 100â€“200 characters.`,
    
    pinDescUser: process.env.PIN_DESC_USER_PROMPT || `Pin Title: {{pinTitle}}
Category: {{category}}
Annotated Interests: {{interests}}
Language: {{language}}
Based on the instructions provided, please write {{pinCount}} different Pinterest Pin description that is optimized for both engagement and SEO. 
Return only the final text without any numbering, dashes, labels, or quotation marks. Do not include "Description 1:", "1.", "-", or any symbols. Just plain clean text.`,
    
    pinOverlaySystem: process.env.PIN_OVERLAY_SYSTEM_PROMPT || `You are a Pinterest marketing and visual copy expert. Your task is to create short, scroll-stopping overlay text for Pinterest images. This overlay should grab attention fast while sparking curiosity â€” using as few words as possible.
Follow these principles:
1. Use **minimal text** â€” 4 to 7 words max
2. **Front-load keywords** for Pinterest SEO (if relevant)
3. Focus on **benefit or transformation** â€” what will the viewer gain?
4. Spark **curiosity** with surprise, specificity, or urgency
5. Use **clear, bold, conversational language** â€” no fluff or vague words
6. Do **not** include punctuation unless it's essential (like parentheses or exclamation points)
7. No hashtags or branding
Tone: Friendly, modern, and direct â€” like a helpful blogger speaking to her Pinterest audience
Bad vs Good (with keyword included naturally):
âŒ "My best slow cooker idea ever!" âœ… "Slow Cooker Chicken That Falls Apart"
âŒ "Some fall organizing tips" âœ… "Fall Closet Organization Made Simple"
âŒ "Ways to save money" âœ… "Save Big on Your Weekly Grocery Bill"
âŒ "Tasty dinner tonight?" âœ… "Easy Crockpot Chicken Tacos Tonight"
âŒ "Meal prep goals!" âœ… "Vegan Meal Prep You'll Actually Love"
Always return 1 short overlay phrase only.`,
    
    pinOverlayUser: process.env.PIN_OVERLAY_USER_PROMPT || `Pin Title: {{pinTitle}}
Language: {{language}}
Create {{pinCount}} short Pinterest image overlay text (4â€“7 words max) that matches the tone and message of the Pin. Use curiosity and benefit-driven language. Keep it concise and bold. 
Return only the final text without any numbering, dashes, labels, or quotation marks. Do not include "Image 1:", "1.", "-", or any symbols. Just plain clean text.`,
    
    metaTitleSystem: process.env.META_TITLE_SYSTEM_PROMPT || `You are an SEO content strategist specializing in crafting compelling and optimized blog post titles.
Your goal is to generate one SEO-friendly blog post title that aligns with current best practices to enhance visibility in search engines and drive clicks.
Context:
The title must attract attention in search engine results pages (SERPs), accurately represent the blog post content, and include the keyword naturally.
Follow these instructions:
- Incorporate the Primary Keyword: Include the main keyword, ideally at the beginning.
- Match Search Intent: Understand what the user is looking for and reflect that in the title.
- Be Descriptive and Concise: Clearly express the value of the post in 50â€“60 characters.
- Avoid Keyword Stuffing: Use keywords naturally â€” no repetition or awkward phrasing.
- Use Power Words and Numbers: Include numbers, brackets, or compelling phrases to increase click-through rates (e.g. "10 Easy Tips", "[2025]", "Best", etc.).
Constraints:
- Character Limit: Maximum of 60 characters
- Tone: Professional, clear, and engaging
- Avoid misleading or clickbait titles
Bad vs Good Examples:
1. Clear & Concise
âŒ Poor: "A Great Dinner Recipe I Love" âœ… Good: Easy Slow Cooker Chicken Tacos
âŒ Poor: "Make This Dish Tonight" âœ… Good: Creamy Garlic Mashed Potatoes Recipe
2. Curiosity-Based
âŒ Poor: "This Might Be the Best Chicken Ever" âœ… Good: The Secret to the Best Slow Cooker Chicken
âŒ Poor: "Wowâ€”Just Try This Pasta" âœ… Good: Why Everyone's Talking About This Pasta Bake
3. Number-Based
âŒ Poor: "Tasty Dinners to Try" âœ… Good: 5 Quick Weeknight Dinners to Try Now
âŒ Poor: "Ideas for Soups" âœ… Good: 7 Cozy Fall Soups You Can Freeze
4. How-To / Instructional
âŒ Poor: "Making Pancakes Like This Is Fun" âœ… Good: How to Make Fluffy Japanese SoufflÃ© Pancakes
âŒ Poor: "Roast Chicken Is Easy If You Know How" âœ… Good: How to Roast Chicken Perfectly Every Time
5. Question-Based
âŒ Poor: "Thinking of Prepping Chicken?" âœ… Good: What's the Best Way to Meal Prep Chicken?
âŒ Poor: "No Eggs? Try This" âœ… Good: Can You Bake a Cake Without Eggs?
6. Mistake-Avoidance
âŒ Poor: "Bread Didn't Turn Out?" âœ… Good: 5 Mistakes That Ruin Banana Bread
âŒ Poor: "Watch Out When You Slow Cook" âœ… Good: Avoid These Slow Cooker Chicken Fails
7. Ultimate Guide
âŒ Poor: "Learn Everything About Chicken Recipes" âœ… Good: The Ultimate Guide to Slow Cooker Chicken
âŒ Poor: "How to Meal Prep All Week" âœ… Good: Complete Guide to Keto Meal Prep for Beginners
8. Comparison
âŒ Poor: "Different Cooking Appliances Compared" âœ… Good: Air Fryer vs. Oven: Which Cooks Faster?
âŒ Poor: "Quinoa or Riceâ€”You Decide" âœ… Good: Quinoa vs. Rice: Which Is Better for Meal Prep?
9. Seasonal / Occasion-Based
âŒ Poor: "Holiday Brunch Recipe Ideas" âœ… Good: Easy Christmas Brunch Ideas Everyone Will Love
âŒ Poor: "Dinner Ideas for Autumn" âœ… Good: Cozy Fall Dinner Recipes for Chilly Nights
10. Trend-Focused
âŒ Poor: "The Newest Internet Food Thing" âœ… Good: TikTok's Viral Baked Oats: Worth the Hype?
âŒ Poor: "This Ice Cream Is Weird But Cool" âœ… Good: Try This Pinterest-Famous Cottage Cheese Ice Cream
Return only one SEO-optimized blog post title.`,
    
    metaTitleUser: process.env.META_TITLE_USER_PROMPT || `Pinterest Pin title: {{pinTitle}}
Language: {{language}}
Please generate 1 SEO blog post title that follows the instructions provided in the system prompt. Make it optimized for search, aligned with the pin title, and under 60 characters. 
Return only the final text without any numbering, dashes, labels, or quotation marks. Do not include "Title 1:", "1.", "-", or any symbols. Just plain clean text.`,
    
    metaDescSystem: process.env.META_DESC_SYSTEM_PROMPT || `You are an SEO content strategist specializing in crafting compelling meta descriptions that enhance search engine visibility and click-through rates. Your goal is to generate an SEO-friendly meta description that accurately summarizes a blog post or webpage and entices users to click.
Context:
The description should align with the page's actual content, include relevant keywords naturally, and appeal to the target audience's search intent.
Follow these instructions:
- Optimal Length: Keep the meta description between 120â€“155 characters so it displays properly in Google results.
- Incorporate Target Keywords: Use the primary keyword naturally and early in the sentence.
- Use Active Voice and Action-Oriented Language: Engage the reader with direct, clear phrasing.
- Gently guide the reader toward clicking by hinting at the value of the content. Instead of direct commands, use friendly phrasing that suggests what they'll gain or enjoy. Encourage clicks with phrases like "A must-try if you love quick, comforting meals" "Discover," "Perfect for your next cozy dinner at home" or "The kind of recipe that saves busy weeknights."
- Ensure Uniqueness: Every description must be unique and not duplicated from other pages.
- Reflect Page Content Accurately: Ensure the summary represents what the post truly offers.
Constraints:
- Character Limit: Maximum of 155 characters
- Tone: Professional, helpful, and engaging
- Avoid keyword stuffing or vague language
Bad vs Good Examples:
1. Clear & Concise Titles
âŒ Poor: "This blog post is about chicken tacos and how to cook them." âœ… Good: "Make these easy slow cooker chicken tacos with simple pantry staples â€” perfect for a no-fuss dinner everyone will love."
2. Curiosity-Based Titles
âŒ Poor: "This recipe is a surprise and very good. You should try it." âœ… Good: "The secret to juicy, flavor-packed chicken is easier than you think â€” one you'll want to make again and again."
3. Number-Based Titles
âŒ Poor: "Here are some recipes to try for dinner or lunch." âœ… Good: "Try these 5 quick dinner ideas that make busy weeknights feel a little easier â€” no fancy ingredients required."
4. How-To Titles
âŒ Poor: "Learn about making pancakes with steps to follow." âœ… Good: "Follow this step-by-step guide to fluffy soufflÃ© pancakes â€” soft, jiggly, and ready to impress."
5. Question-Based Titles
âŒ Poor: "This blog post will answer your question about baking a cake." âœ… Good: "Wondering how to bake a cake without eggs? This easy recipe has you covered with simple swaps and delicious results."
6. Mistake-Avoidance Titles
âŒ Poor: "Here are some mistakes to avoid when cooking." âœ… Good: "Avoid these common bread-baking mistakes to get soft, golden loaves every time â€” great if you're just starting out."
7. Ultimate Guide Titles
âŒ Poor: "Everything you need to know is in this blog post." âœ… Good: "This ultimate slow cooker chicken guide has everything you need â€” from tips to variations and serving ideas."
8. Comparison Titles
âŒ Poor: "This post compares two different cooking methods." âœ… Good: "Not sure if the air fryer or oven is better? This comparison breaks it down with time, texture, and taste in mind."
9. Seasonal / Occasion-Based Titles
âŒ Poor: "Recipes for the holidays and other times of the year." âœ… Good: "Warm up your table with these cozy fall dinner recipes â€” easy comfort food perfect for chilly nights."
10. Trend-Focused Titles
âŒ Poor: "Try this trending recipe from the internet." âœ… Good: "This TikTok-famous baked oats recipe is easy, wholesome, and totally worth the hype."
Return only one SEO-optimized meta description.`,
    
    metaDescUser: process.env.META_DESC_USER_PROMPT || `Pinterest Pin title: {{pinTitle}}
Pinterest Pin description: {{pinDesc}}
Language: {{language}}
Please generate 1 SEO meta description that aligns with this Pin's topic. Follow the system instructions to optimize for both search and click-throughs. 
Return only the final text without any numbering, dashes, labels, or quotation marks. Do not include "Title 1:", "1.", "-", or any symbols. Just plain clean text.`,
    
    slugSystemPrompt: process.env.SLUG_SYSTEM_PROMPT || `You are an SEO specialist. Your task is to generate a short, clean, and keyword-optimized blog post slug based on the provided meta title and recipe idea.
Slug Format Rules:
- Use only lowercase letters
- Replace spaces with hyphens (kebab-case)
- Use 3 to 6 important words only (max ~60 characters total)
- Include 1 or 2 primary keywords from the title or recipe idea
- Remove stopwords like "a", "the", "and", "to", "with", "of", etc.
- Do NOT include domain names, slashes, or punctuation
- Match the title's core idea, but keep it short and search-friendly
Output Requirements:
Return only the final slug (no quotes, no formatting, no label).`,
    
    slugUserPrompt: process.env.SLUG_USER_PROMPT || `Recipe Idea: {{recipeIdea}}  
Meta Title: {{metaTitle}}
Please generate a short, SEO-optimized blog post slug based on the title and keyword.`,
    
    blogpostSystemPrompt: process.env.BLOGPOST_SYSTEM_PROMPT || `You are a food blogger and SEO content strategist writing for the brand Wanda Recipes.
Tone & Brand Voice:
- Audience: American women who love quick, easy, homemade meals
- Tone: Friendly, informative, and encouraging â€” like chatting with a friend in the kitchen
- Guidelines: Use warm, clear language. Avoid jargon. Be helpful, real, and supportive. Make readers feel at home and inspired to try the recipe.
Your task is to write a fully SEO-optimized blog post for a recipe based on the following inputs: meta title, meta description, category, and annotated interest.
Write with search performance and readability in mind. The blog post should rank well on Google and delight readers.
ðŸ§  CONTENT STRUCTURE:
Write a blog post using this structure, but DO NOT repeat these section headers literally. Instead, optimize all section titles dynamically for SEO and clarity.
1. **INTRODUCTION**
   - Begin with a friendly hook that draws the reader in
   - Include the primary keyword naturally in the first 1â€“2 sentences
   - Add a personal anecdote or story to build trust and relatability
3. **INGREDIENTS**
   - Break into clear bullet points
   - Provide brief, helpful tips where relevant
   - Mention tools needed for success
4. **STEP-BY-STEP INSTRUCTIONS** 
   - Use numbered steps  
   - Each step should begin with a short, clear title (like a mini heading) to guide the reader (e.g., "1. Whisk the Batter" or "3. Flip and Cook")  
   - Follow the title with a beginner-friendly explanation  
   - Add casual encouragement, helpful tips, or notes if relevant (e.g., "Don't worry if it looks messy here â€” that's normal!")  
5. **FREQUENTLY ASKED QUESTIONS**
   - Include 4â€“5 questions your audience might Google
   - Answer clearly and supportively in Wanda's voice
6. **CLOSING / CALL-TO-ACTION**
   - Wrap up with encouragement to try the recipe
   - Suggest sharing on Pinterest or tagging on social
   - Include a soft, warm sign-off like a kitchen friend would use
---
ðŸ” SEO REQUIREMENTS (Based on Semrush Best Practices):
- Use the **meta title** as the blog post's H1
- Include the **primary keyword** within the first 100 words
- Naturally include **secondary keywords** (if implied in annotated interest)
- Use proper **H2 and H3 subheadings** with relevant keywords
- Incorporate **internal links** (if relevant) and **external links** to reputable sources
- Include **image suggestions** or alt text phrases with keywords
- Ensure content length is 800â€“1,200 words
- Avoid keyword stuffing, clickbait, or robotic phrasing
---
ðŸ“‹ OUTPUT RULES:
- Use SEO-optimized section headings based on the content and recipe keyword but write them as plain text â€” do NOT use markdown symbols like \`##\`, \`**\`, or numbers
- Format all headings as plain lines of text above their paragraph (e.g., "Why You'll Love This Recipe")
- Do NOT repeat or copy the outline structure or headings from the system prompt
- Do NOT use any markdown, HTML, or numbered formatting
- Return ONLY clean, human-readable blog content ready to copy into WordPress
---
Return **only the blog post content**. Do not include markdown or HTML. Format it as plain, publish-ready text.`,
    
    blogpostUserPrompt: process.env.BLOGPOST_USER_PROMPT || `Please write a full SEO-optimized blog post for the following recipe topic:
Recipe Idea (Main Keyword): {{recipeIdea}}  
Meta Title: {{metaTitle}}  
Meta Description: {{metaDescription}}  
Category: {{category}}  
Annotated Interests: {{interests}}
Language: {{language}}
Do not repeat or label the sections â€” just use helpful headings and clean, natural text.  
Avoid any markdown symbols, numbers, or bold/italic styles.  
Return only the final blog content as plain text.
Use the blog structure and tone described in the system prompt.  
Do not include outline labels or formatting (no bold, headings, asterisks, or HTML).  
Return **only the blog content** as clean, plain text.  
Make it copy-paste ready for WordPress.
Follow the blog structure and tone described in the system prompt but rewrite section headings dynamically with SEO-friendly, benefit-focused language. Return only the blog post content as clean, publish-ready plain text. Do not include markdown, bullet formatting symbols, or explanations â€” just the blog content.`,
    
    fbPrompt: process.env.FB_PROMPT || `Create a complete recipe for {{recipeIdea}} in {{language}}. Include:
1. An emoji and title at the beginning
2. A brief introduction (2-3 sentences)
3. Ingredients section with emoji ðŸ§‚ and ingredients listed with bullet points
4. Preparation section with emoji ðŸ§‘â€ðŸ³ and numbered steps
5. A cooking tip at the end

Be detailed but concise, and ensure the recipe is delicious and practical.`,
    
    mjTemplate: process.env.MJ_TEMPLATE || `Professional food photography of {{title}}, ingredients include {{ingredients}}, photo taken with a Canon EOS R5, 85mm lens, f/2.8, natural lighting, food styling, shallow depth of field, mouth-watering, magazine quality, top view, soft shadows, textured wood or marble background, garnished beautifully`,
    
    fbCaptionPrompt: process.env.FB_CAPTION_PROMPT || `Create an engaging Facebook post caption for this recipe in {{language}}. The caption should be conversational, include 2-3 emojis, ask an engaging question, and invite comments. Keep it under 150 words and make sure it entices people to try the recipe. Here's the recipe:

{{recipe}}`
  }
};

// Make the moment library available to templates
app.locals.moment = moment;

// Home page - now shows recent recipes
// Home page - now shows recent recipes with organization filtering
// Home page - now shows recent recipes with organization filtering and activity statistics
app.get('/', isAuthenticated, async (req, res) => {
  try {
    // Get organization ID from session
    const organizationId = req.session.user.organizationId;
    const userId = req.session.user.role === 'employee' ? req.session.user.id : null;
    const isAdmin = req.session.user.role === 'admin';
    
    // Collect dashboard statistics
    const dashboardStats = {
      recipes: 0,
      pendingKeywords: 0,
      processedKeywords: 0,
      failedKeywords: 0,
      totalKeywords: 0,
      wordpressPosts: 0,
      userCount: 0
    };
    
    // Get recent recipes filtered by organization and optionally by user
    let recentRecipes;
    if (userId) {
      // For employees, only show their recipes
      recentRecipes = await recipeDb.getRecipesByOwnerAndOrg(userId, organizationId, 10, 0);
    } else {
      // For admins, show all recipes in their organization
      recentRecipes = await recipeDb.getRecipesByOrg(organizationId, 10, 0);
    }
    
    // Gather keyword statistics
    dashboardStats.pendingKeywords = await keywordsDb.getKeywordsCount('pending', null, userId, organizationId);
    dashboardStats.processedKeywords = await keywordsDb.getKeywordsCount('processed', null, userId, organizationId);
    dashboardStats.failedKeywords = await keywordsDb.getKeywordsCount('failed', null, userId, organizationId);
    dashboardStats.totalKeywords = dashboardStats.pendingKeywords + dashboardStats.processedKeywords + dashboardStats.failedKeywords;
    
    // Get recipe count
    if (userId) {
      dashboardStats.recipes = await recipeDb.getRecipeCountByOwner(userId);
    } else {
      dashboardStats.recipes = await recipeDb.getRecipeCountByOrganization(organizationId);
    }
    
    // Get WordPress post count if we have WordPress integration
    try {
      dashboardStats.wordpressPosts = await wordpressDb.getPublicationCount(userId, organizationId);
    } catch (error) {
      console.log('No WordPress publications found or error counting them:', error.message);
    }
    
    // If admin, get user count in organization
    if (isAdmin) {
      const orgUsers = await userDb.getUsersByOrganization(organizationId);
      dashboardStats.userCount = orgUsers.length;
      
      // Get recent activity for the organization
      dashboardStats.recentActivity = await getRecentActivityLogs(organizationId, 5);
      
      // Get employee performance stats
      dashboardStats.employeeStats = await getEmployeeStats(organizationId);
    } else {
      // For employees, get their own activity
      dashboardStats.recentActivity = await getRecentActivityLogs(organizationId, 5, userId);
    }
    
    // Ensure promptConfig is properly formatted
    if (promptConfig && !promptConfig.prompts) {
      promptConfig = {
        model: promptConfig.model || 'gpt-4-turbo-preview',
        temperature: promptConfig.temperature || 0.7,
        apiKey: promptConfig.apiKey || process.env.OPENAI_API_KEY,
        language: promptConfig.language || 'English',
        pinCount: promptConfig.pinCount || 10,
        prompts: { ...promptConfig }
      };
    }
    
    res.render('index', { 
      promptConfig: promptConfig || {},
      recentRecipes,
      stats: dashboardStats,
      isAdmin: isAdmin,
      pageTitle: 'Dashboard',
      activePage: 'dashboard',
      title: 'RecipeGen AI - Dashboard'
    });
  } catch (error) {
    console.error('Error fetching dashboard data:', error);
    res.render('index', { 
      promptConfig: promptConfig || {},
      recentRecipes: [],
      stats: {},
      error: 'Failed to load dashboard data: ' + error.message,
      pageTitle: 'Dashboard',
      activePage: 'dashboard',
      title: 'RecipeGen AI - Dashboard'
    });
  }
});

// Helper function to get recent activity logs
async function getRecentActivityLogs(organizationId, limit = 5, userId = null) {
  try {
    // If we don't have an activity log table yet, return empty array
    const hasActivityTable = await checkTableExists('activity_logs');
    if (!hasActivityTable) {
      return [];
    }
    
    let query = `
      SELECT al.*, u.name as user_name 
      FROM activity_logs al
      JOIN users u ON al.user_id = u.id
      WHERE al.organization_id = ?
    `;
    
    const params = [organizationId];
    
    if (userId) {
      query += ` AND al.user_id = ?`;
      params.push(userId);
    }
    
    query += ` ORDER BY al.created_at DESC LIMIT ?`;
    params.push(limit);
    
    return await getAll(query, params);
  } catch (error) {
    console.error('Error getting activity logs:', error);
    return [];
  }
}

// Helper function to get employee stats
async function getEmployeeStats(organizationId) {
  try {
    // Get all employees in the organization
    const employees = await userDb.getUsersByOrganization(organizationId);
    const employeeIds = employees.filter(u => u.role === 'employee').map(u => u.id);
    
    if (employeeIds.length === 0) {
      return [];
    }
    
    // Get stats for each employee
    const stats = [];
    
    for (const id of employeeIds) {
      const employee = employees.find(u => u.id === id);
      
      // Skip if not found (should never happen)
      if (!employee) continue;
      
      // Get counts
      const recipeCount = await recipeDb.getRecipeCountByOwner(id);
      const keywordCounts = {
        pending: await keywordsDb.getKeywordsCount('pending', null, id),
        processed: await keywordsDb.getKeywordsCount('processed', null, id),
        failed: await keywordsDb.getKeywordsCount('failed', null, id)
      };
      
      // Calculate total
      keywordCounts.total = keywordCounts.pending + keywordCounts.processed + keywordCounts.failed;
      
      // Get WordPress posts if we have WordPress integration
      let wpPostCount = 0;
      try {
        wpPostCount = await wordpressDb.getPublicationCount(id, organizationId);
      } catch (error) {
        // Ignore error if WordPress integration not set up
      }
      
      stats.push({
        id: id,
        name: employee.name,
        email: employee.email,
        recipeCount,
        keywordCounts,
        wpPostCount,
        totalContent: recipeCount + keywordCounts.processed
      });
    }
    
    // Sort by total content in descending order
    return stats.sort((a, b) => b.totalContent - a.totalContent);
  } catch (error) {
    console.error('Error getting employee stats:', error);
    return [];
  }
}

// Helper function to check if a table exists
async function checkTableExists(tableName) {
  try {
    const result = await getOne(
      `SELECT name FROM sqlite_master WHERE type='table' AND name=?`,
      [tableName]
    );
    return !!result;
  } catch (error) {
    console.error(`Error checking if table ${tableName} exists:`, error);
    return false;
  }
}

// Updated Settings Route for server.js
// Replace your existing settings GET route with this one

app.get('/settings', isAuthenticated, async (req, res) => {
  try {
    const successMessage = req.session.successMessage;
    const errorMessage = req.session.errorMessage;
    delete req.session.successMessage; // Clear the message after use
    delete req.session.errorMessage; // Clear the error message after use
    
    // Ensure promptConfig is properly formatted
    if (promptConfig && !promptConfig.prompts) {
      promptConfig = {
        model: promptConfig.model || 'gpt-4-turbo-preview',
        temperature: promptConfig.temperature || 0.7,
        apiKey: promptConfig.apiKey || process.env.OPENAI_API_KEY,
        language: promptConfig.language || 'English',
        pinCount: promptConfig.pinCount || 10,
        prompts: { ...promptConfig }
      };
    }
    
    // Get API key information - force a fresh check from the database
    const openaiKey = await apiKeyManager.getApiKey('openai');
    console.log('Settings page - API key status:', openaiKey ? 'Found' : 'Not found');
    
    const apiKeys = {
      openai: openaiKey ? true : false
    };
    
    res.render('settings', { 
      promptConfig: promptConfig || {},
      successMessage: successMessage,
      errorMessage: errorMessage,
      pageTitle: 'Prompt Settings',
      activePage: 'settings',
      title: 'RecipeGen AI - Settings',
      apiKeys: apiKeys
    });
  } catch (error) {
    console.error('Error loading settings page:', error);
    res.render('settings', { 
      promptConfig: promptConfig || {},
      successMessage: null,
      errorMessage: 'Error loading settings: ' + error.message,
      pageTitle: 'Prompt Settings',
      activePage: 'settings',
      title: 'RecipeGen AI - Settings',
      apiKeys: { openai: false }
    });
  }
});


// Add these routes to your server.js file before the 404 handler

// Keywords management page with organization filtering
// Keywords management page with organization filtering - FIXED VERSION
// Keywords management page with organization filtering - FIXED VERSION
app.get('/keywords', isAuthenticated, async (req, res) => {
  try {
    // Get organization ID from session
    const organizationId = req.session.user.organizationId;
    const userId = req.session.user.role === 'employee' ? req.session.user.id : null;
    const userRole = req.session.user.role;
    
    console.log(`Loading keywords for ${userRole} (${userId}) in organization: ${organizationId}`);
    
    // Get query parameters for filtering and pagination
    const status = req.query.status || null;
    const page = parseInt(req.query.page || '1');
    const search = req.query.search || null;
    const limit = 50;
    const offset = (page - 1) * limit;

    // Get keywords with filters
    let keywords = [];
    if (userRole === 'employee') {
      // Employees only see their keywords
      keywords = await keywordsDb.getKeywordsByOwner(userId, status, limit, offset, search);
      console.log(`Retrieved ${keywords.length} keywords for employee ${userId}`);
    } else {
      // Admins see all keywords in their organization
      keywords = await keywordsDb.getKeywordsByOrganization(organizationId, status, limit, offset, search);
      console.log(`Retrieved ${keywords.length} keywords for organization ${organizationId}`);
    }
    
    // Get total count for pagination (with same filters)
    let totalCount = 0;
    if (userRole === 'employee') {
      totalCount = await keywordsDb.getKeywordsCount(status, search, userId);
    } else {
      totalCount = await keywordsDb.getKeywordsCount(status, search, null, organizationId);
    }
    
    const totalPages = Math.ceil(totalCount / limit);
    
    // Count by status for statistics
    let pendingCount = 0, processedCount = 0, failedCount = 0;
    if (userRole === 'employee') {
      pendingCount = await keywordsDb.getKeywordsCount('pending', null, userId);
      processedCount = await keywordsDb.getKeywordsCount('processed', null, userId);
      failedCount = await keywordsDb.getKeywordsCount('failed', null, userId);
    } else {
      pendingCount = await keywordsDb.getKeywordsCount('pending', null, null, organizationId);
      processedCount = await keywordsDb.getKeywordsCount('processed', null, null, organizationId);
      failedCount = await keywordsDb.getKeywordsCount('failed', null, null, organizationId);
    }
    
    res.render('keywords', {
  pageTitle: 'Keywords Management',
  activePage: 'keywords',
  title: 'RecipeGen AI - Keywords Management',
  keywords,
  currentPage: page,
  totalPages,
  totalCount,
  limit,
  status,
  search: search,  // CHANGED FROM searchTerm to search
  stats: {
    pending: pendingCount,
    processed: processedCount,
    failed: failedCount,
    total: totalCount
  }
});
  } catch (error) {
    console.error('Error loading keywords page:', error);
    res.render('error', {
      message: 'Failed to load keywords',
      error: error,
      pageTitle: 'Error',
      activePage: '',
      title: 'RecipeGen AI - Error'
    });
  }
});

// Add keywords API endpoint
// Add keywords API endpoint - FIXED VERSION
// Add keywords API endpoint - FIXED VERSION
// Add this debugging before we process the keywords
// In server.js, update the /api/keywords/add endpoint (around line 1470) with this improved debugging:
app.post('/api/keywords/add', isAuthenticated, activityMiddleware.logActivity('create', 'keyword'), async (req, res) => {
    try {
    console.log('Request body for keyword addition:', JSON.stringify(req.body, null, 2));
    
    let keywordsData = [];
    
    // Get user ID and organization ID from session
    const ownerId = req.session.user.id;
    const organizationId = req.session.user.organizationId;
    
    console.log(`User ID: ${ownerId}, Organization ID: ${organizationId}`);
    
    if (!ownerId || !organizationId) {
      const errorMsg = 'User authentication required - missing user ID or organization ID';
      console.error(errorMsg);
      return res.status(401).json({
        success: false,
        message: errorMsg
      });
    }
    
    // Check if data is coming from regular form submission
    if (req.body.keywords && typeof req.body.keywords === 'string') {
      // Split by lines and convert to array of objects
      keywordsData = req.body.keywords.split('\n')
        .map(line => line.trim())
        .filter(line => line.length > 0)
        .map(line => ({ 
          keyword: line,
          category: req.body.defaultCategory || null,
          interests: req.body.defaultInterests || null,
          ownerId: ownerId,
          organizationId: organizationId
        }));
      console.log('Processed string keywords as:', keywordsData);
    } else if (req.body.keywords && Array.isArray(req.body.keywords)) {
      // Data is already in the correct format (from JavaScript handler)
      keywordsData = req.body.keywords.map(keyword => {
        if (typeof keyword === 'string') {
          return {
            keyword: keyword.trim(),
            category: req.body.defaultCategory || null,
            interests: req.body.defaultInterests || null,
            ownerId: ownerId,
            organizationId: organizationId
          };
        } else if (typeof keyword === 'object' && keyword.keyword) {
          return {
            keyword: keyword.keyword.trim(),
            category: keyword.category || req.body.defaultCategory || null,
            interests: keyword.interests || req.body.defaultInterests || null,
            ownerId: ownerId,
            organizationId: organizationId
          };
        }
        return null;
      }).filter(k => k !== null && k.keyword && k.keyword.trim().length > 0);
      
      console.log('Processed array keywords as:', keywordsData);
    }
    
    if (keywordsData.length === 0) {
      const errorMsg = 'No valid keywords provided after processing';
      console.error(errorMsg, { originalBody: req.body });
      return res.status(400).json({
        success: false,
        message: errorMsg
      });
    }
    
    // Add keywords to database
    console.log(`Attempting to add ${keywordsData.length} keywords to database`);
    const keywordIds = await keywordsDb.addKeywordsBatch(keywordsData);
    
    console.log(`Successfully added ${keywordIds.length} keywords to database`);
    
    // Return JSON response for API clients
    return res.json({
      success: true,
      message: `Added ${keywordIds.length} keywords successfully`,
      count: keywordIds.length
    });
    
  } catch (error) {
    console.error('Error adding keywords:', error);
    
    return res.status(500).json({
      success: false,
      message: error.message || 'An unknown error occurred'
    });
  }
});

// Process selected keywords API endpoint
// Process selected keywords API endpoint
app.post('/api/keywords/process-selected', isAuthenticated, activityMiddleware.logActivity('process', 'keyword'), async (req, res) => {
  try {
    const { keywordIds, contentOption } = req.body;
    
    if (!keywordIds || !Array.isArray(keywordIds) || keywordIds.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'No keywords selected for processing'
      });
    }
    
    console.log(`Processing ${keywordIds.length} selected keywords with option: ${contentOption}`);
    
    // Get organization ID and user ID from session
    const organizationId = req.session.user.organizationId;
    const userId = req.session.user.id;
    
    // Get full keyword data for the selected IDs
    const selectedKeywords = await keywordsDb.getKeywordsByIds(keywordIds);
    
    if (selectedKeywords.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'No keywords found with the provided IDs'
      });
    }
    
    // Process each keyword
    const results = [];
    
    for (const keyword of selectedKeywords) {
      try {
        // Verify keyword belongs to user's organization
        if (keyword.organization_id !== organizationId) {
          results.push({
            id: keyword.id,
            keyword: keyword.keyword,
            category: keyword.category,
            status: 'skipped',
            message: 'Keyword does not belong to your organization',
          });
          continue;
        }
        
        // For employees, verify they own the keyword
        if (req.session.user.role === 'employee' && keyword.owner_id !== userId) {
          results.push({
            id: keyword.id,
            keyword: keyword.keyword,
            category: keyword.category,
            status: 'skipped',
            message: 'You do not have permission to process this keyword',
          });
          continue;
        }
        
        // Skip keywords that are already processed
        if (keyword.status === 'processed') {
          results.push({
            id: keyword.id,
            keyword: keyword.keyword,
            category: keyword.category,
            status: 'skipped',
            message: 'Keyword already processed',
            recipeId: keyword.recipe_id
          });
          continue;
        }
        
        // Create recipe record - using keyword.keyword instead of recipeIdea
        const recipeId = await recipeDb.createRecipe({
          recipeIdea: keyword.keyword.trim(),
          category: keyword.category,
          interests: keyword.interests,
          language: promptConfig.language || 'English',
          ownerId: userId,
          organizationId: organizationId
        });
        
        // Update app.js config with current promptConfig
        const appModule = require('./app');
        appModule.updateConfig({
          model: promptConfig.model,
          apiKey: promptConfig.apiKey,
          language: promptConfig.language,
          temperature: promptConfig.temperature,
          pinCount: promptConfig.pinCount,
          prompts: promptConfig.prompts
        });
        
        // Generate content based on selected option
        if (contentOption === 'facebook' || contentOption === 'all') {
          // Generate Facebook content (creates the basic recipe)
          const facebookContent = await appModule.generateFacebookContent(keyword.keyword);
          
          if (facebookContent) {
            // Save Facebook content
            await facebookDb.saveFacebookContent(recipeId, facebookContent);
          }
        }
        
        if (contentOption === 'pinterest' || contentOption === 'all') {
          // Generate Pinterest content
          const pinterestContent = await appModule.generatePinterestContent(
            keyword.keyword,
            keyword.category,
            keyword.interests
          );
          
          // Save Pinterest variations
          if (pinterestContent && pinterestContent.length > 0) {
            for (let i = 0; i < pinterestContent.length; i++) {
              await pinterestDb.savePinterestVariation(
                recipeId,
                pinterestContent[i],
                i + 1
              );
            }
            
            // Generate blog post from first Pinterest variation
            if (pinterestContent.length > 0) {
              const blogContent = await appModule.generateBlogPost(
                keyword.keyword,
                keyword.category,
                keyword.interests,
                pinterestContent[0].metaTitle,
                pinterestContent[0].metaDesc
              );
              
              if (blogContent) {
                await blogDb.saveBlogContent(
                  recipeId,
                  blogContent,
                  // Assuming the first variation ID is stored somewhere or can be retrieved
                  null
                );
              }
            }
          }
        }
        
        await keywordsDb.updateKeywordStatus(keyword.id, 'processed', recipeId);
        
        // Add to results
        results.push({
          id: keyword.id,
          keyword: keyword.keyword,
          category: keyword.category,
          status: 'processed',
          recipeId: recipeId,
          contentOption: contentOption
        });
        
      } catch (error) {
        console.error(`Error processing keyword "${keyword.keyword}":`, error);
        
        // Update keyword status to failed
        await keywordsDb.updateKeywordStatus(keyword.id, 'failed');
        
        results.push({
          id: keyword.id,
          keyword: keyword.keyword,
          category: keyword.category,
          status: 'failed',
          message: error.message || 'Failed to process'
        });
      }
    }
    
    // Return results
    res.json({
      success: true,
      results: results
    });
    
  } catch (error) {
    console.error('Error processing selected keywords:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'An unknown error occurred'
    });
  }
});

// Delete keywords API endpoint
app.post('/api/keywords/delete', isAuthenticated, activityMiddleware.logActivity('delete', 'keyword'), async (req, res) => {
  try {
    const { keywordIds } = req.body;
    
    if (!keywordIds || !Array.isArray(keywordIds) || keywordIds.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'No keywords selected for deletion'
      });
    }
    
    console.log(`Deleting ${keywordIds.length} keywords`);
    
    // Delete the keywords
    await keywordsDb.deleteKeywords(keywordIds);
    
    res.json({
      success: true,
      message: `Deleted ${keywordIds.length} keywords successfully`,
      count: keywordIds.length
    });
    
  } catch (error) {
    console.error('Error deleting keywords:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'An unknown error occurred'
    });
  }
});

// Process keywords API endpoint
app.post('/api/keywords/process',isAuthenticated, async (req, res) => {
  try {
    const { keywords, autoGenerate } = req.body;
    
    if (!keywords || !Array.isArray(keywords) || keywords.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'No valid keywords provided'
      });
    }
    
    console.log(`Processing ${keywords.length} keywords, autoGenerate: ${autoGenerate}`);
    
    // Process each keyword
    const results = [];
    
    for (const keyword of keywords) {
      try {
        // Validate the keyword
        if (!keyword.recipeIdea || typeof keyword.recipeIdea !== 'string' || keyword.recipeIdea.trim().length === 0) {
          results.push({
            recipeIdea: keyword.recipeIdea || 'Empty',
            category: keyword.category,
            success: false,
            message: 'Invalid recipe idea'
          });
          continue;
        }
        
        // Create recipe record
        // Create a new recipe
recipeId = await recipeDb.createRecipe({
  recipeIdea,
  category,
  interests,
  language: promptConfig.language,
  ownerId: req.user.id,
  organizationId: req.organizationId
});
        
        // If auto-generate is enabled, generate content for this recipe
        if (autoGenerate) {
          try {
            // Update app.js config with current promptConfig
            const appModule = require('./app');
            appModule.updateConfig({
              model: promptConfig.model,
              apiKey: promptConfig.apiKey,
              language: promptConfig.language,
              temperature: promptConfig.temperature,
              pinCount: promptConfig.pinCount,
              prompts: promptConfig.prompts
            });
            
            // Generate Facebook content (creates the basic recipe)
            const facebookContent = await appModule.generateFacebookContent(keyword.recipeIdea);
            
            if (facebookContent) {
              // Save Facebook content
              await facebookDb.saveFacebookContent(recipeId, facebookContent);
              
              // Optionally generate Pinterest content
              try {
                const pinterestContent = await appModule.generatePinterestContent(
                  keyword.recipeIdea,
                  keyword.category,
                  keyword.interests
                );
                
                // Save Pinterest variations
                if (pinterestContent && pinterestContent.length > 0) {
                  for (let i = 0; i < pinterestContent.length; i++) {
                    await pinterestDb.savePinterestVariation(
                      recipeId,
                      pinterestContent[i],
                      i + 1
                    );
                  }
                }
              } catch (pinterestError) {
                console.warn(`Pinterest generation error for "${keyword.recipeIdea}":`, pinterestError);
              }
            }
          } catch (generateError) {
            console.warn(`Content generation error for "${keyword.recipeIdea}":`, generateError);
            // We continue despite generation errors since the recipe was created
          }
        }
        
        // Add to results
        results.push({
          recipeIdea: keyword.recipeIdea,
          category: keyword.category,
          success: true,
          recipeId: recipeId
        });
        
      } catch (keywordError) {
        console.error(`Error processing keyword "${keyword.recipeIdea}":`, keywordError);
        
        results.push({
          recipeIdea: keyword.recipeIdea,
          category: keyword.category,
          success: false,
          message: keywordError.message || 'Failed to process'
        });
      }
    }
    
    // Return results
    res.json({
      success: true,
      results: results
    });
    
  } catch (error) {
    console.error('Error processing keywords:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'An unknown error occurred'
    });
  }
});

// Update to the server.js settings POST route to ensure the API key is passed to app.js

app.post('/settings', (req, res) => {
  console.log('Received settings update');
  
  try {
    // Get the API key directly from the form
    const openaiApiKey = req.body.openaiApiKey;
    
    // Update prompt configuration
    promptConfig = {
      model: req.body.model || 'gpt-4-turbo-preview',
      temperature: parseFloat(req.body.temperature || '0.7'),
      apiKey: openaiApiKey,  // Set API key directly from form
      language: req.body.language || 'English',
      pinCount: parseInt(req.body.pinCount || '10'),
      prompts: {
        pinTitleSystem: req.body.pinTitleSystem || '',
        pinTitleUser: req.body.pinTitleUser || '',
        pinDescSystem: req.body.pinDescSystem || '',
        pinDescUser: req.body.pinDescUser || '',
        pinOverlaySystem: req.body.pinOverlaySystem || '',
        pinOverlayUser: req.body.pinOverlayUser || '',
        metaTitleSystem: req.body.metaTitleSystem || '',
        metaTitleUser: req.body.metaTitleUser || '',
        metaDescSystem: req.body.metaDescSystem || '',
        metaDescUser: req.body.metaDescUser || '',
        slugSystemPrompt: req.body.slugSystemPrompt || '',
        slugUserPrompt: req.body.slugUserPrompt || '',
        blogpostSystemPrompt: req.body.blogpostSystemPrompt || '',
        blogpostUserPrompt: req.body.blogpostUserPrompt || '',
        fbPrompt: req.body.fbPrompt || '',
        mjTemplate: req.body.mjTemplate || '',
        fbCaptionPrompt: req.body.fbCaptionPrompt || ''
      }
    };
    
    console.log('Updated promptConfig with new API key');
    
    // IMPORTANT: Update the app.js module with the new config
    const appModule = require('./app');
    appModule.updateConfig({
      model: promptConfig.model,
      temperature: promptConfig.temperature,
      apiKey: openaiApiKey,  // Explicitly pass the API key
      language: promptConfig.language,
      pinCount: promptConfig.pinCount,
      prompts: promptConfig.prompts
    });
    
    console.log('Updated app.js module configuration');
    
    // Store in session
    req.session.promptConfig = promptConfig;
    
    // Redirect with success message
    req.session.successMessage = 'Settings saved successfully!';
    res.redirect('/settings');
  } catch (error) {
    console.error('Error saving settings:', error);
    req.session.errorMessage = `Error saving settings: ${error.message}`;
    res.redirect('/settings');
  }
});



// PinClicks Analysis API Endpoint
app.post('/api/analyze-pinclicks',isAuthenticated, async (req, res) => {
  try {
    const { csv, keyword } = req.body;
    
    if (!csv || !keyword) {
      return res.status(400).json({
        success: false,
        message: 'CSV data and keyword are required'
      });
    }
    
    console.log(`Analyzing PinClicks data for keyword: ${keyword}`);
    
    // Parse the CSV
    const csvLines = csv.split('\n');
    if (csvLines.length < 2) {
      return res.status(400).json({
        success: false,
        message: 'CSV is empty or invalid'
      });
    }
    
    const headers = csvLines[0].split(',');
    
    // Extract keywords and their occurrence data
    const keywordData = [];
    for (let i = 1; i < csvLines.length; i++) {
      const line = csvLines[i].trim();
      if (!line) continue;
      
      const columns = line.split(',');
      if (columns.length >= 2) {
        const keywordCol = columns[0].trim();
        const occurrences = parseInt(columns[1]) || 0;
        
        if (keywordCol && occurrences > 0) {
          keywordData.push({
            keyword: keywordCol,
            occurrences
          });
        }
      }
    }
    
    // Simple algorithm to extract interests
    const relevantKeywords = keywordData
      .filter(item => item.occurrences >= 3)
      .sort((a, b) => b.occurrences - a.occurrences)
      .slice(0, 10) // Take top 10
      .map(item => item.keyword.toLowerCase())
      .filter(keyword => keyword.length > 2); // Remove very short keywords
    
    const interests = relevantKeywords.join(', ');
    
    return res.json({
      success: true,
      interests: interests
    });
  } catch (error) {
    console.error('Error analyzing PinClicks data:', error);
    return res.status(500).json({
      success: false,
      message: error.message || 'An unknown error occurred'
    });
  }
});
// Recipe browser page
// Recipe browser page - Updated version with limit variable
app.get('/recipes', isAuthenticated, isResourceOwner, async (req, res) => {
  try {
    // Get search parameters
    const searchTerm = req.query.search || '';
    const page = parseInt(req.query.page) || 1;
    const limit = 20; // Define the limit
    const offset = (page - 1) * limit;
    
    // Use the filters set by isResourceOwner middleware
    let recipes;
    
    if (req.session.user.role === 'employee') {
      // Employees see only their content
      if (searchTerm) {
        recipes = await recipeDb.searchRecipesByOwner(req.session.user.id, searchTerm, limit, offset);
      } else {
        recipes = await recipeDb.getRecipesByOwnerAndOrg(req.session.user.id, req.session.user.organizationId, limit, offset);
      }
    } else {
      // Admins see all org content
      if (searchTerm) {
        recipes = await recipeDb.searchRecipesInOrganization(req.session.user.organizationId, searchTerm, limit, offset);
      } else {
        recipes = await recipeDb.getRecipesByOrg(req.session.user.organizationId, limit, offset);
      }
    }
    
    res.render('recipes', { 
      recipes,
      searchTerm,
      pageTitle: 'Browse Recipes',
      activePage: 'recipes',
      title: 'RecipeGen AI - Recipe Browser',
      currentPage: page,
      totalPages: 1, // You can update this if you implement pagination
      limit: limit   // Pass the limit variable to the template
    });
  } catch (error) {
    console.error('Error loading recipes:', error);
    res.render('error', { 
      message: 'Failed to load recipes',
      error: error,
      pageTitle: 'Error',
      activePage: '',
      title: 'RecipeGen AI - Error'
    });
  }
});

// Individual recipe view page
// Individual recipe view page - updated to pass organizationId
app.get('/recipe/:id', isAuthenticated, async (req, res) => {
  try {
    const recipeId = req.params.id;
    
    // Get the recipe details
    const recipe = await recipeDb.getRecipeById(recipeId);
    if (!recipe) {
      return res.status(404).render('error', {
        message: 'Recipe not found',
        error: { status: 404 },
        pageTitle: 'Error',
        activePage: '',
        title: 'RecipeGen AI - Error'
      });
    }
    
    // Check if user has access to this recipe
    const orgId = req.session.user.organizationId;
    const userId = req.session.user.role === 'employee' ? req.session.user.id : null;
    
    if (recipe.organization_id !== orgId || 
        (userId && recipe.owner_id !== userId)) {
      return res.status(403).render('error', {
        message: 'You do not have permission to view this recipe',
        error: { status: 403 },
        pageTitle: 'Error',
        activePage: '',
        title: 'RecipeGen AI - Error'
      });
    }
    
    // Get the associated content - pass organizationId and userId if employee
    const facebook = await facebookDb.getFacebookContentByRecipeId(
      recipeId, 
      orgId,
      userId
    );
    const pinterestVariations = await pinterestDb.getVariationsByRecipeId(recipeId);
    const blog = await blogDb.getBlogContentByRecipeId(recipeId);
    
    res.render('recipe-view', { 
      recipe,
      facebook,
      pinterestVariations,
      blog,
      pageTitle: recipe.recipe_idea,
      activePage: 'recipes',
      title: `RecipeGen AI - ${recipe.recipe_idea}`
    });
  } catch (error) {
    console.error('Error fetching recipe details:', error);
    res.status(500).render('error', {
      message: 'Failed to load recipe details',
      error: error,
      pageTitle: 'Error',
      activePage: '',
      title: 'RecipeGen AI - Error'
    });
  }
});

// Generator pages
app.get('/generate/pinterest',isAuthenticated, (req, res) => {
  res.render('generate-pinterest', {
  pageTitle: 'Generate Pinterest & Blog',
  activePage: 'generate-pinterest',
  title: 'RecipeGen AI - Generate Pinterest & Blog'
});
});

app.get('/generate/facebook',isAuthenticated, (req, res) => {
  res.render('generate-facebook', {
  pageTitle: 'Generate Facebook & Midjourney',
  activePage: 'generate-facebook',
  title: 'RecipeGen AI - Generate Facebook & Midjourney'
});
});

app.get('/generate/all',isAuthenticated, (req, res) => {
  res.render('generate-all', {
  pageTitle: 'Generate All Content',
  activePage: 'generate-all',
  title: 'RecipeGen AI - Generate All Content'
});
});

// API Endpoints
// Test OpenAI API connection
app.post('/api/test-connection', async (req, res) => {
  const { model, apiKey: providedApiKey } = req.body;
  
  // Use provided API key or get from database/env
  let apiKey = providedApiKey;
  if (!apiKey || apiKey.includes('â€¢')) {
    // Try to get the key from the database first, then fall back to env if needed
    apiKey = await apiKeyManager.getApiKey('openai');
    
    // If still no key, use the one from promptConfig
    if (!apiKey) {
      apiKey = promptConfig.apiKey;
    }
  }
  
  if (!model) {
    return res.json({
      success: false,
      message: 'Model is required'
    });
  }
  
  if (!apiKey) {
    return res.json({
      success: false,
      message: 'No API key available. Please provide an OpenAI API key.'
    });
  }
  
  try {
    const response = await axios.post(
      'https://api.openai.com/v1/chat/completions',
      {
        model: model,
        messages: [
          { role: 'user', content: 'Hello, this is a test message. Please respond with "Connection successful".' }
        ],
        max_tokens: 20
      },
      {
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${apiKey}`
        }
      }
    );
    
    if (response.data && response.data.choices && response.data.choices.length > 0) {
      return res.json({
        success: true,
        message: 'Connection successful',
        model: model,
        response: response.data.choices[0].message.content.trim()
      });
    } else {
      return res.json({
        success: false,
        message: 'Invalid response from API'
      });
    }
  } catch (error) {
    console.error('API test error:', error.response?.data || error.message);
    return res.json({
      success: false,
      message: error.response?.data?.error?.message || error.message
    });
  }
});

// Fixed /api/generate/facebook endpoint
app.post('/api/generate/facebook', isAuthenticated, activityMiddleware.logActivity('create', 'recipe'), async (req, res) => {
  try {
    let { recipeIdea } = req.body;
    
    // Make sure recipeIdea is a clean string
    recipeIdea = (recipeIdea || '').trim();
    
    if (!recipeIdea) {
      return res.status(400).json({
        success: false,
        message: 'Recipe idea is required'
      });
    }
    
    console.log('Generating Facebook content for recipe idea:', recipeIdea);
    
    // Update app.js config with current promptConfig
    const appModule = require('./app');
    appModule.updateConfig({
      model: promptConfig.model,
      apiKey: promptConfig.apiKey,
      language: promptConfig.language,
      temperature: promptConfig.temperature,
      pinCount: promptConfig.pinCount,
      prompts: promptConfig.prompts || {
        fbPrompt: promptConfig.fbPrompt,
        mjTemplate: promptConfig.mjTemplate,
        fbCaptionPrompt: promptConfig.fbCaptionPrompt
      }
    });
    
    // Generate the content
    const facebookContent = await generateFacebookContent(recipeIdea);
    
    // Initialize category and interests from request body
    const category = req.body.category || null;
    const interests = req.body.interests || null;
    
    // Create recipe record in database
    const recipeId = await recipeDb.createRecipe({
      recipeIdea,
      category,
      interests, 
      language: promptConfig.language,
      ownerId: req.user.id,
      organizationId: req.organizationId
    });
    
    console.log('Created recipe record with ID:', recipeId);
    
    // Make sure facebookContent exists and has expected structure
    if (!facebookContent) {
      throw new Error('Failed to generate Facebook content');
    }
    
    // Save Facebook content in database
    const facebookId = await facebookDb.saveFacebookContent(
      recipeId,
      facebookContent
    );
    
    console.log('Saved Facebook content with ID:', facebookId);
    
    // Ensure we're returning a properly structured response
    // with all necessary properties to prevent undefined errors
    res.json({
      success: true,
      data: {
        recipeId: recipeId,
        facebook: {
          id: facebookId,
          recipe: facebookContent.recipe || '',
          title: facebookContent.title || '',
          fbCaption: facebookContent.fbCaption || '',
          mjPrompt: facebookContent.mjPrompt || '',
          ingredients: facebookContent.allIngredients || ''
        }
      }
    });
  } catch (error) {
    console.error('Error generating Facebook content:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'An unknown error occurred'
    });
  }
});

// Generate Pinterest content
// Fixed /api/generate/pinterest endpoint
app.post('/api/generate/pinterest', isAuthenticated, activityMiddleware.logActivity('create', 'recipe'), async (req, res) => {
try {
    const { recipeIdea, category, interests, generateBlog = false } = req.body;
    
    if (!recipeIdea) {
      return res.status(400).json({
        success: false,
        message: 'Recipe idea is required'
      });
    }
    
    // Update app.js config with current promptConfig
    const appModule = require('./app');
    appModule.updateConfig({
      model: promptConfig.model,
      apiKey: promptConfig.apiKey,
      language: promptConfig.language,
      temperature: promptConfig.temperature,
      pinCount: promptConfig.pinCount,
      prompts: promptConfig.prompts
    });
    
    // First check if we need to create a new recipe or there's an existing one
    let recipeId;
    const existingRecipes = await recipeDb.searchRecipes(recipeIdea, 1, 0);
    if (existingRecipes && existingRecipes.length > 0 && 
        existingRecipes[0].recipe_idea.toLowerCase() === recipeIdea.toLowerCase()) {
      // Use existing recipe
      recipeId = existingRecipes[0].id;
      console.log('Using existing recipe with ID:', recipeId);
    } else {
      // Create a new recipe
      recipeId = await recipeDb.createRecipe({
        recipeIdea,
        category,
        interests,
        language: promptConfig.language
      });
      console.log('Created new recipe with ID:', recipeId);
    }
    
    // IMPORTANT: First generate Facebook content to establish recipe details
    console.log('First generating Facebook content to establish recipe details...');
    const facebookContent = await generateFacebookContent(recipeIdea);
    
    // Save Facebook content if it doesn't exist yet
    const existingFacebook = await facebookDb.getFacebookContentByRecipeId(recipeId);
    if (!existingFacebook) {
      await facebookDb.saveFacebookContent(recipeId, facebookContent);
      console.log('Saved Facebook content for recipe ID:', recipeId);
    }
    
    // Now generate Pinterest content
    const pinterestContent = await generatePinterestContent(recipeIdea, category, interests);
    
    if (!pinterestContent || pinterestContent.length === 0) {
      throw new Error('Failed to generate Pinterest content');
    }
    
    // Save Pinterest variations to database
    const variationIds = [];
    for (let i = 0; i < pinterestContent.length; i++) {
      const variationId = await pinterestDb.savePinterestVariation(
        recipeId,
        pinterestContent[i],
        i + 1
      );
      variationIds.push(variationId);
      console.log(`Saved Pinterest variation ${i+1} with ID:`, variationId);
    }
    
    // If generateBlog flag is true, generate the blog post (for backward compatibility)
    let blogContent = null;
    let blogId = null;
    
    if (generateBlog) {
      const variation = pinterestContent[0];
      blogContent = await generateBlogPost(
        recipeIdea,
        category, 
        interests,
        variation.metaTitle,
        variation.metaDesc
      );
      
      // Save blog post to database
      blogId = await blogDb.saveBlogContent(
        recipeId,
        blogContent,
        variationIds[0]
      );
      console.log('Saved blog content with ID:', blogId);
    }
    
    // Files are no longer needed with our database approach, but we'll maintain
    // compatibility with old code that expects file URLs
    const files = {
      pinterest: `/recipe/${recipeId}`,
      results: `/recipe/${recipeId}`
    };
    
    if (blogContent) {
      files.blog = `/recipe/${recipeId}`;
    }
    
    res.json({
      success: true,
      recipeId: recipeId,
      data: {
        recipeId: recipeId,
        pinterest: pinterestContent,
        blog: blogContent
      },
      files: files
    });
  } catch (error) {
    console.error('Error generating Pinterest content:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'An unknown error occurred'
    });
  }
});

// Fixed /api/generate/all endpoint
app.post('/api/generate/all', isAuthenticated, activityMiddleware.logActivity('create', 'recipe'), async (req, res) => {
    try {
    const { recipeIdea } = req.body;
    
    if (!recipeIdea) {
      return res.status(400).json({
        success: false,
        message: 'Recipe idea is required'
      });
    }
    
    // Update app.js config with current promptConfig
    const appModule = require('./app');
    appModule.updateConfig({
      model: promptConfig.model,
      apiKey: promptConfig.apiKey,
      language: promptConfig.language,
      temperature: promptConfig.temperature,
      pinCount: promptConfig.pinCount,
      prompts: promptConfig.prompts
    });
    
    // Initialize category and interests from request body
    const category = req.body.category || null;
    const interests = req.body.interests || null;
    
    // Create recipe record in database
    const recipeId = await recipeDb.createRecipe({
      recipeIdea,
      category,
      interests,
      language: promptConfig.language,
      ownerId: req.user.id,
      organizationId: req.organizationId
    });
    
    console.log('Created recipe record with ID:', recipeId);
    
    // IMPORTANT CHANGE: Generate Facebook content FIRST
    // This ensures the recipe details are stored in sharedRecipeState
    // before generating the blog post
    console.log('Generating Facebook content first to establish recipe details...');
    const facebookContent = await generateFacebookContent(recipeIdea);
    
    if (!facebookContent) {
      throw new Error('Failed to generate Facebook content');
    }
    
    // Save Facebook content
    const facebookId = await facebookDb.saveFacebookContent(
      recipeId,
      facebookContent
    );
    
    console.log('Saved Facebook content with ID:', facebookId);
    
    // Now generate Pinterest content
    const pinterestContent = await generatePinterestContent(recipeIdea, category, interests);
    
    if (!pinterestContent || pinterestContent.length === 0) {
      throw new Error('Failed to generate Pinterest content');
    }
    
    // Save Pinterest variations
    const variationIds = [];
    for (let i = 0; i < pinterestContent.length; i++) {
      const variationId = await pinterestDb.savePinterestVariation(
        recipeId,
        pinterestContent[i],
        i + 1
      );
      variationIds.push(variationId);
      console.log(`Saved Pinterest variation ${i+1} with ID:`, variationId);
    }
    
    // Generate blog content from first Pinterest variation
    // By generating Facebook first, the blog will use those recipe details
    let blogContent = null;
    let blogId = null;
    
    if (pinterestContent.length > 0) {
      const variation = pinterestContent[0];
      blogContent = await generateBlogPost(
        recipeIdea,
        category,
        interests,
        variation.metaTitle,
        variation.metaDesc
      );
      
      if (!blogContent) {
        console.warn('Blog content generation returned null or empty');
        blogContent = ''; // Provide default empty string
      }
      
      // Save blog content
      blogId = await blogDb.saveBlogContent(
        recipeId,
        blogContent,
        variationIds[0]
      );
      
      console.log('Saved blog content with ID:', blogId);
    }
    
    // Files are no longer needed with our database approach, but we'll maintain
    // compatibility with old code that expects file URLs
    const files = {
      results: `/recipe/${recipeId}`,
      pinterest: `/recipe/${recipeId}`,
      facebook: `/recipe/${recipeId}`
    };
    
    if (blogContent) {
      files.blog = `/recipe/${recipeId}`;
    }
    
    res.json({
      success: true,
      recipeId: recipeId,
      data: {
        recipeId: recipeId,
        pinterest: pinterestContent,
        blog: blogContent,
        facebook: {
          recipe: facebookContent.recipe || '',
          title: facebookContent.title || '',
          fbCaption: facebookContent.fbCaption || '',
          mjPrompt: facebookContent.mjPrompt || ''
        }
      },
      files: files
    });
  } catch (error) {
    console.error('Error generating all content:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'An unknown error occurred'
    });
  }
});

// Fixed blog generation from variation endpoint
// Fixed blog-from-variation endpoint that specifically handles index vs ID issue
app.post('/api/generate/blog-from-variation',isAuthenticated, async (req, res) => {
  try {
    // Get parameters from request
    const { recipeId, variationId, variationIndex } = req.body;
    
    console.log('Blog generation request params:', { 
      recipeId, 
      variationId, 
      variationIndex
    });
    
    // Require recipeId
    if (!recipeId) {
      return res.status(400).json({
        success: false,
        message: 'Recipe ID is required'
      });
    }
    
    // Get recipe details
    const recipe = await recipeDb.getRecipeById(recipeId);
    if (!recipe) {
      console.error('Recipe not found with ID:', recipeId);
      return res.status(404).json({
        success: false,
        message: 'Recipe not found'
      });
    }
    
    // Get all Pinterest variations for this recipe
    const allVariations = await pinterestDb.getVariationsByRecipeId(recipeId);
    console.log(`Found ${allVariations.length} variations for recipe ID: ${recipeId}`);
    
    if (!allVariations || allVariations.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'No Pinterest variations found for this recipe'
      });
    }
    
    // Find the variation to use for blog generation
    let variation = null;
    
    // First check if we have a valid variationIndex
    if (variationIndex !== undefined && variationIndex !== null) {
      const index = parseInt(variationIndex);
      console.log(`Attempting to find variation by index: ${index}`);
      
      if (!isNaN(index) && index >= 0 && index < allVariations.length) {
        variation = allVariations[index];
        console.log(`Found variation by index ${index}, ID: ${variation.id}`);
      }
    }
    
    // If no variation found by index, try by ID
    if (!variation && variationId) {
      console.log(`Attempting to find variation by ID: ${variationId}`);
      
      // Try direct lookup
      variation = await pinterestDb.getVariationById(variationId);
      
      // If variationId looks like a number (not a UUID), it might be an index
      if (!variation && /^\d+$/.test(variationId)) {
        const index = parseInt(variationId);
        console.log(`variationId appears to be a numeric index: ${index}, trying array lookup`);
        
        if (!isNaN(index) && index >= 0 && index < allVariations.length) {
          variation = allVariations[index];
          console.log(`Found variation by numeric ID (treated as index): ${index}`);
        }
      }
    }
    
    // If still no variation, use the first one
    if (!variation && allVariations.length > 0) {
      variation = allVariations[0];
      console.log(`No specific variation found, using first variation: ${variation.id}`);
    }
    
    // If we still have no variation, something is wrong
    if (!variation) {
      console.error('Could not find any usable Pinterest variation');
      return res.status(404).json({
        success: false,
        message: 'Pinterest variation not found'
      });
    }
    
    // Log the variation we're using
    console.log('Using variation:', {
      id: variation.id,
      variation_number: variation.variation_number,
      pin_title: variation.pin_title
    });
    
    // Update app.js config with current promptConfig
    const appModule = require('./app');
    appModule.updateConfig({
      model: promptConfig.model,
      apiKey: promptConfig.apiKey,
      language: promptConfig.language || recipe.language || 'English',
      temperature: promptConfig.temperature,
      pinCount: promptConfig.pinCount,
      prompts: promptConfig.prompts
    });
    
    // Generate blog content
    console.log(`Generating blog content for: ${recipe.recipe_idea}`);
    console.log(`Using meta title: ${variation.meta_title}`);
    console.log(`Using meta description: ${variation.meta_description}`);
    
    const blogContent = await generateBlogPost(
      recipe.recipe_idea,
      recipe.category,
      recipe.interests,
      variation.meta_title,
      variation.meta_description
    );
    
    // Handle case when blog content generation fails
    if (!blogContent) {
      console.error('Blog content generation returned null or undefined');
      return res.status(500).json({
        success: false,
        message: 'Failed to generate blog content'
      });
    }
    
    // Save or update blog content
    const blogId = await blogDb.updateBlogContent(
      recipeId,
      blogContent,
      variation.id
    );
    
    console.log('Saved/updated blog content with ID:', blogId);
    
    // Return the blog content
    res.json({
      success: true,
      blogId,
      blogContent
    });
    
  } catch (error) {
    console.error('Error generating blog from variation:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to generate blog from variation: ' + (error.message || 'Unknown error')
    });
  }
});

// Adding backward compatibility for filesystem-based storage approach
// This helps when transitioning from the old system to the new database system
app.post('/api/generate/blog-from-variation-fs', isAuthenticated, async (req, res) => {
  try {
    const { recipeIdea, category, interests, variation } = req.body;
    
    if (!variation || !variation.metaTitle || !variation.metaDesc) {
      return res.status(400).json({
        success: false,
        message: 'Invalid Pinterest variation provided'
      });
    }
    
    // Update app.js config with current promptConfig
    const appModule = require('./app');
    appModule.updateConfig({
      model: promptConfig.model,
      apiKey: promptConfig.apiKey,
      language: promptConfig.language,
      temperature: promptConfig.temperature,
      pinCount: promptConfig.pinCount,
      prompts: promptConfig.prompts
    });
    
    console.log(`Generating blog post for Pinterest variation: "${variation.pinTitle}"`);
    console.log(`Using meta title: "${variation.metaTitle}"`);
    console.log(`Using meta description: "${variation.metaDesc}"`);
    
    // Generate blog content using the selected variation's meta title and description
    const blogContent = await generateBlogPost(
      recipeIdea,
      category,
      interests,
      variation.metaTitle,
      variation.metaDesc
    );
    
    // Create output directory for filesystem storage (backward compatibility)
    const outputDir = path.join(__dirname, 'output', recipeIdea.replace(/[^a-z0-9]/gi, '_').toLowerCase());
    fs.mkdirSync(outputDir, { recursive: true });
    
    // Save the blog content to filesystem
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const blogOutputFile = path.join(outputDir, `${timestamp}-blog-post-variation-${variation.metaSlug}.html`);
    fs.writeFileSync(blogOutputFile, blogContent);
    
    // Return the blog content and file path
    res.json({
      success: true,
      blogContent: blogContent,
      blogFile: `/output/${recipeIdea.replace(/[^a-z0-9]/gi, '_').toLowerCase()}/${path.basename(blogOutputFile)}`
    });
    
  } catch (error) {
    console.error('Error generating blog from variation (filesystem):', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
});

// Serve output files (for backward compatibility)
app.use('/output', express.static(path.join(__dirname, 'output')));

// Alternative endpoint to delete recipes (using POST)
app.post('/api/recipes/delete/:id',isAuthenticated, async (req, res) => {
  console.log('POST delete endpoint hit with ID:', req.params.id);
  try {
    const recipeId = req.params.id;
    
    if (!recipeId) {
      console.log('No recipe ID provided');
      return res.status(400).json({
        success: false,
        message: 'Recipe ID is required'
      });
    }
    
    console.log('Checking if recipe exists:', recipeId);
    // Check if the recipe exists first
    const recipe = await recipeDb.getRecipeById(recipeId);
    if (!recipe) {
      console.log('Recipe not found with ID:', recipeId);
      return res.status(404).json({
        success: false,
        message: 'Recipe not found'
      });
    }
    
    console.log('Deleting recipe with ID:', recipeId);
    // Delete the recipe and all its associated content
    const result = await recipeDb.deleteRecipe(recipeId);
    
    if (result) {
      console.log('Successfully deleted recipe');
      return res.json({
        success: true,
        message: 'Recipe deleted successfully'
      });
    } else {
      console.log('Failed to delete recipe - database returned false');
      return res.status(500).json({
        success: false,
        message: 'Failed to delete recipe'
      });
    }
  } catch (error) {
    console.error('Error deleting recipe:', error);
    
    // Make sure we return JSON even in error cases
    return res.status(500).json({
      success: false,
      message: error.message || 'An unknown error occurred'
    });
  }
});

// Add these before your existing WordPress routes

// WP Recipe Maker settings page
app.get('/wordpress-recipe-settings', isAuthenticated, async (req, res) => {
  try {
    // Load both WordPress and WPRM settings
    const wpSettings = await wordpressDb.getSettings();
    
    // Require recipe DB module
    const recipeDb = require('./wordpress-recipe-db');
    const wprmSettings = await recipeDb.getSettings();
    
    res.render('wordpress-recipe-settings', {
      pageTitle: 'WP Recipe Maker Settings',
      activePage: 'wordpress-recipe-settings',
      title: 'RecipeGen AI - WP Recipe Maker Settings',
      wpSettings: wpSettings || {},
      settings: wprmSettings || {},
      successMessage: req.session.successMessage || null,
      errorMessage: req.session.errorMessage || null
    });
    
    // Clear session messages
    delete req.session.successMessage;
    delete req.session.errorMessage;
  } catch (error) {
    console.error('Error loading WP Recipe Maker settings:', error);
    res.render('wordpress-recipe-settings', {
      pageTitle: 'WP Recipe Maker Settings',
      activePage: 'wordpress-recipe-settings',
      title: 'RecipeGen AI - WP Recipe Maker Settings',
      wpSettings: {},
      settings: {},
      successMessage: null,
      errorMessage: 'Failed to load WP Recipe Maker settings: ' + error.message
    });
  }
});

// Save WP Recipe Maker settings
app.post('/wordpress-recipe-settings', async (req, res) => {
  try {
    const { enabled, addToAllPosts, keywords } = req.body;
    
    // Require recipe DB module
    const recipeDb = require('./wordpress-recipe-db');
    
    // Save settings
    await recipeDb.saveSettings({
      enabled: enabled === 'on',
      addToAllPosts: addToAllPosts === 'on',
      keywords: keywords || ''
    });
    
    req.session.successMessage = 'WP Recipe Maker settings saved successfully!';
    res.redirect('/wordpress-recipe-settings');
  } catch (error) {
    console.error('Error saving WP Recipe Maker settings:', error);
    req.session.errorMessage = 'Failed to save WP Recipe Maker settings: ' + error.message;
    res.redirect('/wordpress-recipe-settings');
  }
});

// Test WP Recipe Maker connection
app.post('/api/wordpress/test-wprm-connection',isAuthenticated, async (req, res) => {
  try {
    // Get WordPress settings
    const wpSettings = await wordpressDb.getSettings();
    
    if (!wpSettings || !wpSettings.site_url || !wpSettings.username || !wpSettings.password) {
      return res.status(400).json({
        success: false,
        message: 'WordPress settings are required. Please configure WordPress first.'
      });
    }
    
    // Configure WordPress API
    const wpConfig = {
      apiUrl: `${wpSettings.site_url}/wp-json/wp/v2`,
      username: wpSettings.username,
      password: wpSettings.password
    };
    
    // Require recipe helper module
    const recipeHelper = require('./recipe-helper');
    
    // Test connection
    const result = await recipeHelper.testWPRMApiConnection(wpConfig);
    
    res.json({
      success: true,
      message: 'WP Recipe Maker connection test successful'
    });
  } catch (error) {
    console.error('WP Recipe Maker connection test error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to connect to WP Recipe Maker'
    });
  }
});

// Publish to WordPress with recipe
// Replace or update the '/api/wordpress/publish-with-recipe' endpoint

// Modify the '/api/wordpress/publish-with-recipe' endpoint in server.js
app.post('/api/wordpress/publish-with-recipe', isAuthenticated, activityMiddleware.logActivity('publish', 'post'), async (req, res) => {
  try {
    const { recipeId, status, customContent, customTitle, formatContent = true, seoMetadata = null } = req.body;
    
    if (!recipeId && !customContent) {
      return res.status(400).json({
        success: false,
        message: 'Either Recipe ID or custom content is required'
      });
    }
    
    // Get WordPress settings
    const wpSettings = await wordpressDb.getSettings();
    if (!wpSettings || !wpSettings.site_url || !wpSettings.username || !wpSettings.password) {
      return res.status(400).json({
        success: false,
        message: 'WordPress settings are not configured. Please set up your WordPress connection first.'
      });
    }
    
    // Get WP Recipe Maker settings
    const recipeDbModule = require('./wordpress-recipe-db');
    const wprmSettings = await recipeDbModule.getSettings();
    
    let content, title, metaSlug = '';
    let recipeData = null;
    let focusKeyword = null;
    let autoSeoMetadata = null;
    
    // If using an existing recipe
    if (recipeId) {
      // Get recipe details
      const recipe = await recipeDb.getRecipeById(recipeId);
      if (!recipe) {
        return res.status(404).json({
          success: false,
          message: 'Recipe not found'
        });
      }
      
      // Store recipe idea as the focus keyword
      focusKeyword = recipe.recipe_idea; 
      
      // Get blog content
      const blog = await blogDb.getBlogContentByRecipeId(recipeId);
      if (!blog || !blog.html_content) {
        return res.status(404).json({
          success: false,
          message: 'No blog content found for this recipe'
        });
      }
      
      content = blog.html_content;
      title = recipe.recipe_idea;
      
      // Get Pinterest variation for meta info
      if (blog.pinterest_variation_id) {
        const variation = await pinterestDb.getVariationById(blog.pinterest_variation_id);
        if (variation) {
          title = variation.meta_title || title;
          metaSlug = variation.meta_slug || '';
          
          // Create auto SEO metadata object from Pinterest variation
          autoSeoMetadata = {
            title: variation.meta_title || title,
            description: variation.meta_description || '',
            permalink: variation.meta_slug || '',
            keyword: focusKeyword
          };
        }
      } else {
        // Try to get the first variation
        const variations = await pinterestDb.getVariationsByRecipeId(recipeId);
        if (variations && variations.length > 0) {
          title = variations[0].meta_title || title;
          metaSlug = variations[0].meta_slug || '';
          
          // Create auto SEO metadata object from Pinterest variation
          autoSeoMetadata = {
            title: variations[0].meta_title || title,
            description: variations[0].meta_description || '',
            permalink: variations[0].meta_slug || '',
            keyword: focusKeyword
          };
        }
      }
      
      // Get Facebook content to extract recipe data
      const facebookContent = await facebookDb.getFacebookContentByRecipeId(recipeId);
      if (facebookContent) {
        // Require recipe helper module
        const recipeHelper = require('./recipe-helper');
        recipeData = recipeHelper.extractRecipeFromFacebookContent(facebookContent);
        
        // Log the extracted recipe data for debugging
        console.log('Extracted recipe data from Facebook content:');
        console.log('- Title:', recipeData?.title);
        console.log('- Ingredients:', recipeData?.ingredients?.length || 0);
        console.log('- Instructions:', recipeData?.instructions?.length || 0);
        
        // Make sure original arrays are set
        if (recipeData && recipeData.ingredients && !recipeData._originalIngredients) {
          recipeData._originalIngredients = [...recipeData.ingredients];
        }
        
        if (recipeData && recipeData.instructions && !recipeData._originalInstructions) {
          recipeData._originalInstructions = [...recipeData.instructions];
        }
      } else {
        console.warn('No Facebook content found for this recipe');
      }
    } else {
      // Use custom content and title
      content = customContent;
      title = customTitle || 'Custom Content';
      
      // If SEO metadata was provided directly, use it
      if (seoMetadata && seoMetadata.keyword) {
        focusKeyword = seoMetadata.keyword;
      }
    }
    
    // Configure WordPress client
    const wpConfig = {
      apiUrl: `${wpSettings.site_url}/wp-json/wp/v2`,
      username: wpSettings.username,
      password: wpSettings.password
    };
    
    // Create the post data
    const postData = {
      title: title,
      content: content,
      status: status || wpSettings.default_status || 'draft',
      slug: metaSlug,
      formatContent: formatContent
    };
    
    // Initialize WordPress client
    const WordPressClient = require('./wordpress');
    const wp = new WordPressClient({
      siteUrl: wpSettings.site_url,
      username: wpSettings.username,
      password: wpSettings.password
    });
    
    let result;
    if (recipeData && wprmSettings.enabled) {
      // Check if we should add recipe based on title
      const shouldAdd = wprmSettings.addToAllPosts || 
                        WordPressClient.shouldAddRecipe(title, wprmSettings);
                        
      console.log(`Should add recipe? ${shouldAdd}`);
      
      if (shouldAdd) {
        // First publish the post
        const postResult = await wp.createPost(postData);
        
        // Then add the recipe
        const recipeHelper = require('./recipe-helper');
        const recipeResult = await recipeHelper.addRecipeToPost(
          wpConfig,
          recipeData,
          postResult.id
        );
        
        // Now apply SEO metadata
        const metadataToApply = seoMetadata || autoSeoMetadata || { 
          title: title,
          description: '',
          permalink: metaSlug,
          keyword: focusKeyword
        };
        
        if (metadataToApply && metadataToApply.keyword) {
          try {
            console.log('Applying SEO metadata with focus keyword:', metadataToApply.keyword);
            await wp.applySeoMetadata(postResult.id, metadataToApply);
            console.log('âœ“ SEO metadata with focus keyword applied successfully');
          } catch (seoError) {
            console.error('Error applying SEO metadata:', seoError.message);
            // Continue despite SEO error
          }
        }
        
        result = {
          success: true,
          post: postResult,
          recipe: recipeResult,
          seo: metadataToApply ? { focusKeyword: metadataToApply.keyword } : null
        };
      } else {
        // Just publish without recipe
        const postResult = await wp.createPost(postData);
        
        // Apply SEO metadata even without recipe
        if (focusKeyword) {
          try {
            const metadataToApply = seoMetadata || autoSeoMetadata || { 
              title: title,
              description: '',
              permalink: metaSlug,
              keyword: focusKeyword
            };
            
            console.log('Applying SEO metadata with focus keyword:', metadataToApply.keyword);
            await wp.applySeoMetadata(postResult.id, metadataToApply);
            console.log('âœ“ SEO metadata with focus keyword applied successfully');
          } catch (seoError) {
            console.error('Error applying SEO metadata:', seoError.message);
          }
        }
        
        result = {
          success: true,
          post: postResult,
          seo: focusKeyword ? { focusKeyword } : null
        };
      }
    } else {
      // Just publish without recipe
      const postResult = await wp.createPost(postData);
      
      // Apply SEO metadata even without recipe
      if (focusKeyword) {
        try {
          const metadataToApply = seoMetadata || autoSeoMetadata || { 
            title: title,
            description: '',
            permalink: metaSlug,
            keyword: focusKeyword
          };
          
          console.log('Applying SEO metadata with focus keyword:', metadataToApply.keyword);
          await wp.applySeoMetadata(postResult.id, metadataToApply);
          console.log('âœ“ SEO metadata with focus keyword applied successfully');
        } catch (seoError) {
          console.error('Error applying SEO metadata:', seoError.message);
        }
      }
      
      result = {
        success: true,
        post: postResult,
        seo: focusKeyword ? { focusKeyword } : null
      };
    }
    
    // Save publication record if using an existing recipe
    if (recipeId) {
      await wordpressDb.savePublication({
        recipeId: recipeId,
        wpPostId: result.post.id,
        wpPostUrl: result.post.link,
        wpStatus: result.post.status
      });
      
      // If a recipe was added, log it
      if (result.recipe && result.recipe.success && result.recipe.recipeId) {
        await recipeDbModule.logRecipePublication({
          recipeId: recipeId,
          wpPostId: result.post.id,
          wprmRecipeId: result.recipe.recipeId
        });
      }
    }
    
    res.json({
      success: true,
      post: {
        id: result.post.id,
        url: result.post.link,
        status: result.post.status,
        title: result.post.title?.rendered || title
      },
      recipe: result.recipe || null,
      seo: result.seo || null
    });
  } catch (error) {
    console.error('Error publishing to WordPress with recipe:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to publish to WordPress'
    });
  }
});
// WordPress settings page
app.get('/wordpress-settings', isAuthenticated, async (req, res) => {
  try {
    // Make sure to pass the user ID when getting settings
    const settings = await wordpressDb.getSettings(req.session.user.id);
    
    res.render('wordpress-settings', {
      pageTitle: 'WordPress Settings',
      activePage: 'wordpress-settings',
      title: 'RecipeGen AI - WordPress Settings',
      settings: settings || {},
      successMessage: req.session.successMessage || null,
      errorMessage: req.session.errorMessage || null
    });
    
    // Clear session messages
    delete req.session.successMessage;
    delete req.session.errorMessage;
  } catch (error) {
    console.error('Error loading WordPress settings:', error);
    res.render('wordpress-settings', {
      pageTitle: 'WordPress Settings',
      activePage: 'wordpress-settings',
      title: 'RecipeGen AI - WordPress Settings',
      settings: {},
      successMessage: null,
      errorMessage: 'Failed to load WordPress settings: ' + error.message
    });
  }
});

// Users management page (admin only)
app.get('/users', isAuthenticated, isAdmin, async (req, res) => {
  try {
    const organizationId = req.session.user.organizationId;
    
    // Get all users in this organization
    const users = await userDb.getUsersByOrganization(organizationId);
    
    // Enrich with statistics for each user
    for (const user of users) {
      // Get recipe count
      user.stats = {
        recipeCount: await recipeDb.getRecipeCountByOwner(user.id),
        processedKeywords: await keywordsDb.getKeywordsCount('processed', null, user.id)
      };
      
      // Get last activity
      const lastActivity = await getOne(
        `SELECT created_at FROM activity_logs 
         WHERE user_id = ? 
         ORDER BY created_at DESC LIMIT 1`,
        [user.id]
      );
      
      if (lastActivity) {
        user.lastActive = lastActivity.created_at;
      }
    }
    
    res.render('users', {
      users: users,
      pageTitle: 'User Management',
      activePage: 'users',
      title: 'RecipeGen AI - User Management'
    });
  } catch (error) {
    console.error('Error loading users page:', error);
    res.render('error', {
      message: 'Failed to load users',
      error: error,
      pageTitle: 'Error',
      activePage: '',
      title: 'RecipeGen AI - Error'
    });
  }
});



// GET route for user edit page
app.get('/users/edit/:id', isAuthenticated, isAdmin, async (req, res) => {
  try {
    const userId = req.params.id;
    const user = await userDb.getUserById(userId);
    
    if (!user) {
      req.session.errorMessage = 'User not found';
      return res.redirect('/users');
    }
    
    res.render('user-edit', {
      pageTitle: 'Edit User',
      activePage: 'users',
      title: 'RecipeGen AI - Edit User',
      user: user
    });
  } catch (error) {
    console.error('Error loading user edit page:', error);
    req.session.errorMessage = 'Failed to load user: ' + error.message;
    res.redirect('/users');
  }
});

// GET route for user delete (with confirmation)
app.get('/users/delete/:id', isAuthenticated, isAdmin, async (req, res) => {
  try {
    const userId = req.params.id;
    
    // Don't allow deleting your own account
    if (userId === req.session.user.id) {
      req.session.errorMessage = 'You cannot delete your own account.';
      return res.redirect('/users');
    }
    
    const user = await userDb.getUserById(userId);
    
    if (!user) {
      req.session.errorMessage = 'User not found';
      return res.redirect('/users');
    }
    
    // Delete the user
    const deleteResult = await userDb.deleteUser(userId);
    
    if (deleteResult) {
      req.session.successMessage = 'User deleted successfully';
    } else {
      req.session.errorMessage = 'Failed to delete user';
    }
    
    res.redirect('/users');
  } catch (error) {
    console.error('Error deleting user:', error);
    req.session.errorMessage = 'Failed to delete user: ' + error.message;
    res.redirect('/users');
  }
});



// POST route for editing user
app.post('/users/edit/:id', isAuthenticated, isAdmin, async (req, res) => {
  try {
    const userId = req.params.id;
    const { name, email, role, password } = req.body;
    
    // Validate required fields
    if (!name || !email || !role) {
      req.session.errorMessage = 'Name, email, and role are required.';
      return res.redirect(`/users/edit/${userId}`);
    }
    
    // Update user
    const updateResult = await userDb.updateUser(userId, {
      name,
      email,
      role,
      password: password ? password : undefined // Only update password if provided
    });
    
    if (updateResult) {
      req.session.successMessage = 'User updated successfully';
      res.redirect('/users');
    } else {
      req.session.errorMessage = 'Failed to update user';
      res.redirect(`/users/edit/${userId}`);
    }
  } catch (error) {
    console.error('Error updating user:', error);
    req.session.errorMessage = 'Failed to update user: ' + error.message;
    res.redirect(`/users/edit/${userId}`);
  }
});
// API endpoint for filtered content (admin only)
// Now replace the API endpoint in your server.js file with this updated version

// API endpoint for filtered content (admin only)
app.get('/api/filtered-content', isAuthenticated, isAdmin, async (req, res) => {
  try {
    const organizationId = req.session.user.organizationId;
    const employeeId = req.query.employeeId || null;
    const contentType = req.query.type || 'all';
    
    // Use the new helper function that handles missing tables gracefully
    const result = await getFilteredContent(organizationId, employeeId, contentType);
    
    res.json(result);
  } catch (error) {
    console.error('Error getting filtered content:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to load filtered content',
      error: error.message
    });
  }
});

// Test WordPress connection
app.post('/api/wordpress/test-connection',isAuthenticated, async (req, res) => {
  try {
    const { siteUrl, username, password } = req.body;
    
    // Validate required fields
    if (!siteUrl || !username || !password) {
      return res.status(400).json({
        success: false,
        message: 'Site URL, username, and password are required.'
      });
    }
    
    // Initialize WordPress client
    const wp = new WordPressClient({
      siteUrl,
      username,
      password
    });
    
    // Test connection
    const result = await wp.validateConnection();
    
    res.json({
      success: true,
      data: result
    });
  } catch (error) {
    console.error('WordPress connection test error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to connect to WordPress'
    });
  }
});

// Publish to WordPress
app.post('/api/wordpress/publish',isAuthenticated, async (req, res) => {
  try {
    const { recipeId, status } = req.body;
    
    if (!recipeId) {
      return res.status(400).json({
        success: false,
        message: 'Recipe ID is required'
      });
    }
    
    // Get WordPress settings
    const settings = await wordpressDb.getSettings();
    if (!settings || !settings.site_url || !settings.username || !settings.password) {
      return res.status(400).json({
        success: false,
        message: 'WordPress settings are not configured. Please set up your WordPress connection first.'
      });
    }
    
    // Get recipe details
    const recipe = await recipeDb.getRecipeById(recipeId);
    if (!recipe) {
      return res.status(404).json({
        success: false,
        message: 'Recipe not found'
      });
    }
    
    // Get blog content
    const blog = await blogDb.getBlogContentByRecipeId(recipeId);
    if (!blog || !blog.html_content) {
      return res.status(404).json({
        success: false,
        message: 'No blog content found for this recipe'
      });
    }
    
    // Get Pinterest variation for meta info
    let metaTitle = recipe.recipe_idea;
    let metaSlug = '';
    let categories = [];
    
    if (blog.pinterest_variation_id) {
      const variation = await pinterestDb.getVariationById(blog.pinterest_variation_id);
      if (variation) {
        metaTitle = variation.meta_title || metaTitle;
        metaSlug = variation.meta_slug || '';
      }
    } else {
      // Try to get the first variation
      const variations = await pinterestDb.getVariationsByRecipeId(recipeId);
      if (variations && variations.length > 0) {
        metaTitle = variations[0].meta_title || metaTitle;
        metaSlug = variations[0].meta_slug || '';
      }
    }
    
    // Initialize WordPress client
    const wp = new WordPressClient({
      siteUrl: settings.site_url,
      username: settings.username,
      password: settings.password
    });
    
    // Create the post
    const postData = {
      title: metaTitle,
      content: blog.html_content,
      status: status || settings.default_status || 'draft',
      categories: categories,
      slug: metaSlug
    };
    
    const result = await wp.createPost(postData);
    
    // Save publication record
    await wordpressDb.savePublication({
      recipeId: recipeId,
      wpPostId: result.id,
      wpPostUrl: result.link,
      wpStatus: result.status
    });
    
    res.json({
      success: true,
      post: {
        id: result.id,
        url: result.link,
        status: result.status,
        title: result.title.rendered
      }
    });
  } catch (error) {
    console.error('Error publishing to WordPress:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to publish to WordPress'
    });
  }
});

// Get WordPress publication history for a recipe
app.get('/api/wordpress/publications/:recipeId',isAuthenticated, async (req, res) => {
  try {
    const recipeId = req.params.recipeId;
    
    if (!recipeId) {
      return res.status(400).json({
        success: false,
        message: 'Recipe ID is required'
      });
    }
    
    const publications = await wordpressDb.getPublicationsByRecipeId(recipeId);
    
    res.json({
      success: true,
      publications: publications || []
    });
  } catch (error) {
    console.error('Error fetching WordPress publications:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to fetch WordPress publications'
    });
  }
});

// Publish to WordPress with content formatting
app.post('/api/wordpress/publish-formatted', isAuthenticated, activityMiddleware.logActivity('publish', 'post'), async (req, res) => {
  try {
    const { recipeId, status, customContent, customTitle, formatContent = true } = req.body;
    
    if (!recipeId && !customContent) {
      return res.status(400).json({
        success: false,
        message: 'Either Recipe ID or custom content is required'
      });
    }
    
    // Get WordPress settings
    const settings = await wordpressDb.getSettings();
    if (!settings || !settings.site_url || !settings.username || !settings.password) {
      return res.status(400).json({
        success: false,
        message: 'WordPress settings are not configured. Please set up your WordPress connection first.'
      });
    }
    
    let content, title, metaSlug = '';
    
    // If using an existing recipe
    if (recipeId) {
      // Get recipe details
      const recipe = await recipeDb.getRecipeById(recipeId);
      if (!recipe) {
        return res.status(404).json({
          success: false,
          message: 'Recipe not found'
        });
      }
      
      // Get blog content
      const blog = await blogDb.getBlogContentByRecipeId(recipeId);
      if (!blog || !blog.html_content) {
        return res.status(404).json({
          success: false,
          message: 'No blog content found for this recipe'
        });
      }
      
      content = blog.html_content;
      title = recipe.recipe_idea;
      
      // Get Pinterest variation for meta info
      if (blog.pinterest_variation_id) {
        const variation = await pinterestDb.getVariationById(blog.pinterest_variation_id);
        if (variation) {
          title = variation.meta_title || title;
          metaSlug = variation.meta_slug || '';
        }
      } else {
        // Try to get the first variation
        const variations = await pinterestDb.getVariationsByRecipeId(recipeId);
        if (variations && variations.length > 0) {
          title = variations[0].meta_title || title;
          metaSlug = variations[0].meta_slug || '';
        }
      }
    } else {
      // Use custom content and title
      content = customContent;
      title = customTitle || 'Custom Content';
    }
    
    // Initialize WordPress client
    const wp = new WordPressClient({
      siteUrl: settings.site_url,
      username: settings.username,
      password: settings.password
    });
    
    // Create the post
    const postData = {
      title: title,
      content: content,
      status: status || settings.default_status || 'draft',
      slug: metaSlug,
      formatContent: formatContent
    };
    
    const result = await wp.createPost(postData);
    
    // Save publication record if using an existing recipe
    if (recipeId) {
      await wordpressDb.savePublication({
        recipeId: recipeId,
        wpPostId: result.id,
        wpPostUrl: result.link,
        wpStatus: result.status
      });
    }
    
    res.json({
      success: true,
      post: {
        id: result.id,
        url: result.link,
        status: result.status,
        title: result.title.rendered
      }
    });
  } catch (error) {
    console.error('Error publishing to WordPress:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to publish to WordPress'
    });
  }
});

app.post('/wordpress-settings', isAuthenticated, async (req, res) => {
  try {
    const { siteUrl, username, password, defaultStatus } = req.body;
    
    // Validate required fields
    if (!siteUrl || !username || !password) {
      req.session.errorMessage = 'Site URL, username, and password are required.';
      return res.redirect('/wordpress-settings');
    }
    
    // Save settings with userId from session
    await wordpressDb.saveSettings({
      userId: req.session.user.id,  // Make sure this is passed correctly
      siteUrl,
      username,
      password,
      defaultStatus: defaultStatus || 'draft'
    });
    
    req.session.successMessage = 'WordPress settings saved successfully!';
    res.redirect('/wordpress-settings');
  } catch (error) {
    console.error('Error saving WordPress settings:', error);
    req.session.errorMessage = 'Failed to save WordPress settings: ' + error.message;
    res.redirect('/wordpress-settings');
  }
});
// Get WordPress settings API endpoint
app.get('/api/wordpress/settings', isAuthenticated, async (req, res) => {
  try {
    const settings = await wordpressDb.getSettings();
    
    if (settings && settings.site_url && settings.username && settings.password) {
      res.json({
        success: true,
        settings: {
          site_url: settings.site_url,
          username: settings.username,
          // Don't send the actual password to the client
          hasPassword: true,
          default_status: settings.default_status || 'draft'
        }
      });
    } else {
      res.json({
        success: false,
        message: 'WordPress settings not configured'
      });
    }
  } catch (error) {
    console.error('Error fetching WordPress settings via API:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch WordPress settings: ' + error.message
    });
  }
});

// Add this route to get recipe template settings
app.get('/wordpress-recipe-templates',isAuthenticated, (req, res) => {
  try {
    // Load template settings
    const settings = recipeTemplateSettings.loadTemplateSettings();
    
    console.log('Loaded template settings:', settings);
    
    // Render the template settings page
    res.render('wordpress-recipe-templates', {
      title: 'Recipe Template Settings',
      settings: settings,
      user: req.user,
      messages: req.flash()
    });
  } catch (error) {
    console.error('Error loading template settings:', error);
    res.status(500).render('error', {
      message: 'Error loading template settings',
      error: error
    });
  }
});


// Add this route to save recipe template settings
app.post('/wordpress-recipe-templates',isAuthenticated, (req, res) => {
  try {
    console.log('Received template settings form data:', req.body);
    
    // Extract settings from request body
    const settings = {
      // Description templates
      defaultDescription: req.body.defaultDescription,
      cakeDescription: req.body.cakeDescription,
      soupDescription: req.body.soupDescription,
      saladDescription: req.body.saladDescription || '',
      chickenDescription: req.body.chickenDescription || '',
      
      // Notes templates settings
      enableStorageNote: req.body.enableStorageNote === 'on',
      storageNoteTemplate: req.body.storageNoteTemplate || '',
      storageDays: parseInt(req.body.storageDays) || 3,
      
      enableMakeAheadNote: req.body.enableMakeAheadNote === 'on',
      makeAheadTemplate: req.body.makeAheadTemplate || '',
      makeAheadHours: parseInt(req.body.makeAheadHours) || 24,
      dishType: req.body.dishType || 'dish',
      extraInstructions: req.body.extraInstructions || 'Cover and refrigerate until ready to serve.'
    };
    
    console.log('Processed settings to save:', settings);
    
    // Save settings
    const saved = recipeTemplateSettings.saveTemplateSettings(settings);
    
    if (saved) {
      // Set success message
      req.flash('success', 'Recipe template settings saved successfully.');
      console.log('Settings saved successfully');
    } else {
      // Set error message
      req.flash('error', 'Error saving recipe template settings.');
      console.log('Error saving settings');
    }
    
    // Redirect back to settings page
    res.redirect('/wordpress-recipe-templates');
  } catch (error) {
    console.error('Error saving template settings:', error);
    req.flash('error', 'Error saving recipe template settings: ' + error.message);
    res.redirect('/wordpress-recipe-templates');
  }
});

// Add error page route
app.use((req, res, next) => {
  res.status(404).render('error', {
    message: 'Page not found',
    error: { status: 404 },
    pageTitle: 'Error',
    activePage: '',
    title: 'RecipeGen AI - Error'
  });
});
app.use((err, req, res, next) => {
  console.error(err.stack);
  // Make sure error is always defined, even if empty
  res.status(err.status || 500).render('error', {
    message: err.message || 'An unexpected error occurred',
    error: err || { status: 500 },  // Ensure error is always an object
    pageTitle: 'Error',
    activePage: '',
    title: 'RecipeGen AI - Error'
  });
});
// API endpoint to delete a recipe - FIXED VERSION
console.log('Registering DELETE /api/recipes/:id route');
app.delete('/api/recipes/:id', isAuthenticated, async (req, res) => {
  console.log('DELETE endpoint hit with ID:', req.params.id);
  try {
    const recipeId = req.params.id;
    
    if (!recipeId) {
      console.log('No recipe ID provided');
      return res.status(400).json({
        success: false,
        message: 'Recipe ID is required'
      });
    }
    
    console.log('Checking if recipe exists:', recipeId);
    // Check if the recipe exists first
    const recipe = await recipeDb.getRecipeById(recipeId);
    if (!recipe) {
      console.log('Recipe not found with ID:', recipeId);
      return res.status(404).json({
        success: false,
        message: 'Recipe not found'
      });
    }
    
    console.log('Deleting recipe with ID:', recipeId);
    // Delete the recipe and all its associated content
    const result = await recipeDb.deleteRecipe(recipeId);
    
    if (result) {
      console.log('Successfully deleted recipe');
      return res.json({
        success: true,
        message: 'Recipe deleted successfully'
      });
    } else {
      console.log('Failed to delete recipe - database returned false');
      return res.status(500).json({
        success: false,
        message: 'Failed to delete recipe'
      });
    }
  } catch (error) {
    console.error('Error deleting recipe:', error);
    
    // Make sure we return JSON even in error cases
    return res.status(500).json({
      success: false,
      message: error.message || 'An unknown error occurred'
    });
  }
});
// Debug: Print all registered routes
const listEndpoints = () => {
  console.log('\n--- REGISTERED ROUTES ---');
  app._router.stack.forEach((r) => {
    if (r.route && r.route.path) {
      Object.keys(r.route.methods).forEach((method) => {
        console.log(`${method.toUpperCase().padEnd(7)} ${r.route.path}`);
      });
    }
  });
  console.log('------------------------\n');
};

listEndpoints();

// PinClicks Analysis API Endpoint
app.post('/api/analyze-pinclicks', async (req, res) => {
  try {
    const { csv, keyword } = req.body;
    
    if (!csv || !keyword) {
      return res.status(400).json({
        success: false,
        message: 'CSV data and keyword are required'
      });
    }
    
    console.log(`Analyzing PinClicks data for keyword: ${keyword}`);
    
    // Parse the CSV
    const csvLines = csv.split('\n');
    if (csvLines.length < 2) {
      return res.status(400).json({
        success: false,
        message: 'CSV is empty or invalid'
      });
    }
    
    const headers = csvLines[0].split(',');
    
    // Extract keywords and their occurrence data
    const keywordData = [];
    for (let i = 1; i < csvLines.length; i++) {
      const line = csvLines[i].trim();
      if (!line) continue;
      
      const columns = line.split(',');
      if (columns.length >= 2) {
        const keywordCol = columns[0].trim();
        const occurrences = parseInt(columns[1]) || 0;
        
        if (keywordCol && occurrences > 0) {
          keywordData.push({
            keyword: keywordCol,
            occurrences
          });
        }
      }
    }
    
    // Simple algorithm to extract interests
    const relevantKeywords = keywordData
      .filter(item => item.occurrences >= 3)
      .sort((a, b) => b.occurrences - a.occurrences)
      .slice(0, 10) // Take top 10
      .map(item => item.keyword.toLowerCase())
      .filter(keyword => keyword.length > 2); // Remove very short keywords
    
    const interests = relevantKeywords.join(', ');
    
    return res.json({
      success: true,
      interests: interests
    });
  } catch (error) {
    console.error('Error analyzing PinClicks data:', error);
    return res.status(500).json({
      success: false,
      message: error.message || 'An unknown error occurred'
    });
  }
});

// Add this diagnostic route to your server.js file

// API key diagnostic endpoint
app.get('/api/diagnose-keys', async (req, res) => {
  try {
    // Check database status
    const dbStatus = await apiKeyManager.checkApiKeyTable();
    
    // Try to get the OpenAI API key
    const hasKey = await apiKeyManager.getApiKey('openai');
    
    // Check environment variables
    const hasEnvKey = process.env.OPENAI_API_KEY ? true : false;
    
    // Get in-memory config
    const configApiKey = promptConfig.apiKey ? true : false;
    
    res.json({
      success: true,
      database: dbStatus,
      apiKeys: {
        openai: {
          found: hasKey ? true : false,
          source: hasKey ? 'Retrieved successfully' : 'Not found'
        }
      },
      environment: {
        OPENAI_API_KEY: hasEnvKey
      },
      config: {
        apiKey: configApiKey
      }
    });
  } catch (error) {
    console.error('Error in API key diagnostic:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Add a visual diagnostic page
app.get('/diagnose-keys', async (req, res) => {
  try {
    // Check database status
    const dbStatus = await apiKeyManager.checkApiKeyTable();
    
    // Try to get the OpenAI API key
    const hasKey = await apiKeyManager.getApiKey('openai');
    
    // Check environment variables
    const hasEnvKey = process.env.OPENAI_API_KEY ? true : false;
    
    // Get in-memory config
    const configApiKey = promptConfig.apiKey ? true : false;
    
    res.send(`
      <html>
        <head>
          <title>API Key Diagnostic</title>
          <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet">
        </head>
        <body>
          <div class="container my-5">
            <h1>API Key Diagnostic</h1>
            
            <div class="card mb-4">
              <div class="card-header">
                <h5>Database Status</h5>
              </div>
              <div class="card-body">
                <pre>${JSON.stringify(dbStatus, null, 2)}</pre>
              </div>
            </div>
            
            <div class="card mb-4">
              <div class="card-header">
                <h5>API Key Status</h5>
              </div>
              <div class="card-body">
                <p>OpenAI API Key: <span class="badge ${hasKey ? 'bg-success' : 'bg-danger'}">${hasKey ? 'Found' : 'Not Found'}</span></p>
              </div>
            </div>
            
            <div class="card mb-4">
              <div class="card-header">
                <h5>Environment Variables</h5>
              </div>
              <div class="card-body">
                <p>OPENAI_API_KEY: <span class="badge ${hasEnvKey ? 'bg-success' : 'bg-danger'}">${hasEnvKey ? 'Set' : 'Not Set'}</span></p>
              </div>
            </div>
            
            <div class="card mb-4">
              <div class="card-header">
                <h5>In-Memory Config</h5>
              </div>
              <div class="card-body">
                <p>apiKey: <span class="badge ${configApiKey ? 'bg-success' : 'bg-danger'}">${configApiKey ? 'Set' : 'Not Set'}</span></p>
              </div>
            </div>
            
            <a href="/settings" class="btn btn-primary">Back to Settings</a>
          </div>
        </body>
      </html>
    `);
  } catch (error) {
    console.error('Error in API key diagnostic page:', error);
    res.status(500).send(`
      <html>
        <head>
          <title>API Key Diagnostic Error</title>
          <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet">
        </head>
        <body>
          <div class="container my-5">
            <div class="alert alert-danger">
              <h4>Error</h4>
              <p>${error.message}</p>
            </div>
            <a href="/settings" class="btn btn-primary">Back to Settings</a>
          </div>
        </body>
      </html>
    `);
  }
});

// User profile page
app.get('/profile', isAuthenticated, async (req, res) => {
  try {
    const userId = req.session.user.id;
    const organizationId = req.session.user.organizationId;
    
    // Get user details
    const user = await userDb.getUserById(userId);

    if (user) {
  // Get user's content statistics if not already attached
  if (!user.stats) {
    user.stats = {
      recipeCount: await recipeDb.getRecipeCountByOwner(user.id),
      keywordCounts: {
        pending: await keywordsDb.getKeywordsCount('pending', null, user.id),
        processed: await keywordsDb.getKeywordsCount('processed', null, user.id),
        failed: await keywordsDb.getKeywordsCount('failed', null, user.id)
      },
      wpPostCount: 0
    };
    
    // Calculate totals
    user.stats.keywordCounts.total = user.stats.keywordCounts.pending + 
                                     user.stats.keywordCounts.processed + 
                                     user.stats.keywordCounts.failed;
    user.stats.totalContent = user.stats.recipeCount + user.stats.keywordCounts.processed;
    
    // Get WordPress post count if applicable
    try {
      user.stats.wpPostCount = await wordpressDb.getPublicationCount(user.id);
    } catch (error) {
      console.log('No WordPress publications found or error counting them:', error.message);
    }
  }
}
    
    // Get activity stats
    const stats = {
      recipeCount: await recipeDb.getRecipeCountByOwner(userId),
      keywordCounts: {
        pending: await keywordsDb.getKeywordsCount('pending', null, userId),
        processed: await keywordsDb.getKeywordsCount('processed', null, userId),
        failed: await keywordsDb.getKeywordsCount('failed', null, userId)
      },
      wpPostCount: 0
    };
    
    // Calculate totals
    stats.keywordCounts.total = stats.keywordCounts.pending + stats.keywordCounts.processed + stats.keywordCounts.failed;
    stats.totalContent = stats.recipeCount + stats.keywordCounts.processed;
    
    // Get WordPress post count if we have WordPress integration
    try {
      stats.wpPostCount = await wordpressDb.getPublicationCount(userId);
    } catch (error) {
      console.log('No WordPress publications found or error counting them:', error.message);
    }
    
    // Get user activity
    const activity = await activityLogger.getRecentActivity(organizationId, 20, userId);
    
    res.render('profile', {
      user: user,
      stats: stats,
      activity: activity,
      pageTitle: 'User Profile',
      activePage: 'profile',
      title: 'RecipeGen AI - User Profile'
    });
  } catch (error) {
    console.error('Error loading profile page:', error);
    res.render('error', {
      message: 'Failed to load profile',
      error: error,
      pageTitle: 'Error',
      activePage: '',
      title: 'RecipeGen AI - Error'
    });
  }
});

// Apply SEO metadata to a WordPress post
app.post('/api/wordpress/apply-seo', isAuthenticated, async (req, res) => {
  try {
    const { postId, seoMetadata } = req.body;
    
    if (!postId || !seoMetadata) {
      return res.status(400).json({
        success: false,
        message: 'Post ID and SEO metadata are required'
      });
    }
    
    // Get WordPress settings
    const settings = await wordpressDb.getSettings();
    if (!settings || !settings.site_url || !settings.username || !settings.password) {
      return res.status(400).json({
        success: false,
        message: 'WordPress settings are not configured. Please set up your WordPress connection first.'
      });
    }
    
    // Initialize WordPress client
    const wp = new WordPressClient({
      siteUrl: settings.site_url,
      username: settings.username,
      password: settings.password
    });
    
    // Apply SEO metadata
    const result = await wp.applySeoMetadata(postId, seoMetadata);
    
    res.json({
      success: true,
      message: 'SEO metadata applied successfully',
      data: result
    });
  } catch (error) {
    console.error('Error applying SEO metadata:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to apply SEO metadata'
    });
  }
});

// API endpoint for updating user
app.post('/api/users/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
        const userId = req.params.id;
        const { name, email, role, password } = req.body;
        
        // Validate required fields
        if (!name || !email || !role) {
            return res.status(400).json({
                success: false,
                message: 'Name, email, and role are required.'
            });
        }
        
        // Update user
        const updateResult = await userDb.updateUser(userId, {
            name,
            email,
            role,
            password: password ? password : undefined // Only update password if provided
        });
        
        if (updateResult) {
            res.json({
                success: true,
                message: 'User updated successfully'
            });
        } else {
            res.status(500).json({
                success: false,
                message: 'Failed to update user'
            });
        }
    } catch (error) {
        console.error('Error updating user:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'An unknown error occurred'
        });
    }
});

// API endpoint for deleting user
app.post('/api/users/:id/delete', isAuthenticated, isAdmin, async (req, res) => {
    try {
        const userId = req.params.id;
        
        // Don't allow deleting your own account
        if (userId === req.session.user.id) {
            return res.status(400).json({
                success: false,
                message: 'You cannot delete your own account.'
            });
        }
        
        // Delete user
        const deleteResult = await userDb.deleteUser(userId);
        
        if (deleteResult) {
            res.json({
                success: true,
                message: 'User deleted successfully'
            });
        } else {
            res.status(500).json({
                success: false,
                message: 'Failed to delete user'
            });
        }
    } catch (error) {
        console.error('Error deleting user:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'An unknown error occurred'
        });
    }
});

// Add this function to your server.js or a separate helper file
async function getWebsiteStats(websiteId, userId = null, userRole = null) {
  try {
    // Default stats object
    const stats = {
      recipes: 0,
      pendingKeywords: 0,
      processedKeywords: 0,
      failedKeywords: 0,
      totalKeywords: 0,
      wordpressPosts: 0
    };
    
    // Get recipe count
    if (userRole === 'employee' && userId) {
      stats.recipes = await recipeDb.getRecipeCountByOwner(userId, websiteId);
    } else {
      stats.recipes = await recipeDb.getRecipeCountByOrganization(null, websiteId);
    }
    
    // Get keyword counts
    const keywordParams = userRole === 'employee' ? { ownerId: userId } : {};
    stats.pendingKeywords = await keywordsDb.getKeywordsCount('pending', null, 
      keywordParams.ownerId, null, websiteId);
    stats.processedKeywords = await keywordsDb.getKeywordsCount('processed', null, 
      keywordParams.ownerId, null, websiteId);
    stats.failedKeywords = await keywordsDb.getKeywordsCount('failed', null, 
      keywordParams.ownerId, null, websiteId);
    
    stats.totalKeywords = stats.pendingKeywords + stats.processedKeywords + stats.failedKeywords;
    
    // Try to get WordPress post count if we have WordPress integration
    try {
      stats.wordpressPosts = await wordpressDb.getPublicationCount(
        userRole === 'employee' ? userId : null, 
        null, 
        websiteId
      );
    } catch (error) {
      console.log('No WordPress publications found or error counting them:', error.message);
    }
    
    return stats;
  } catch (error) {
    console.error('Error getting website stats:', error);
    return {
      recipes: 0,
      pendingKeywords: 0,
      processedKeywords: 0,
      failedKeywords: 0,
      totalKeywords: 0,
      wordpressPosts: 0
    };
  }
}

// Helper function to get recent content for a website
async function getRecentWebsiteContent(websiteId, userId = null, userRole = null) {
  try {
    const recentContent = [];
    const limit = 10;
    
    // Get recent recipes
    const recipeParams = userRole === 'employee' ? { ownerId: userId } : {};
    const recipes = await recipeDb.getRecipesByOrg(
      null, 
      limit, 
      0, 
      websiteId
    );
    
    if (recipes && recipes.length > 0) {
      recipes.forEach(recipe => {
        recentContent.push({
          id: recipe.id,
          title: recipe.recipe_idea,
          type: 'recipe',
          created_at: recipe.created_at,
          url: `/recipe/${recipe.id}`
        });
      });
    }
    
    // Get recent keywords
    const keywords = await keywordsDb.getKeywords(
      null, 
      limit, 
      0, 
      null,
      userRole === 'employee' ? userId : null,
      null,
      websiteId
    );
    
    if (keywords && keywords.length > 0) {
      keywords.forEach(keyword => {
        recentContent.push({
          id: keyword.id,
          title: keyword.keyword,
          type: 'keyword',
          created_at: keyword.added_at,
          status: keyword.status,
          url: `/keywords?search=${encodeURIComponent(keyword.keyword)}`
        });
      });
    }
    
    // Sort by creation date
    recentContent.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
    
    // Return the most recent items
    return recentContent.slice(0, limit);
  } catch (error) {
    console.error('Error getting recent website content:', error);
    return [];
  }
}


// Start server
app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});




module.exports = app;